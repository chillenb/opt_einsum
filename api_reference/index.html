
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../examples/large_expr_with_greedy/">
      
      
        <link rel="next" href="../changelog/">
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.25">
    
    
      
        <title>API Reference - Optimized Einsum</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.6543a935.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="../css/custom.css">
    
    <script>__md_scope=new URL("..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#api-documentation" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Optimized Einsum" class="md-header__button md-logo" aria-label="Optimized Einsum" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Optimized Einsum
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              API Reference
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m14.3 16-.7-2h-3.2l-.7 2H7.8L11 7h2l3.2 9h-1.9M20 8.69V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69m-9.15 3.96h2.3L12 9l-1.15 3.65Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: light)" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="(prefers-color-scheme: dark)" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to system preference"  type="radio" name="__palette" id="__palette_2">
    
      <label class="md-header__button md-icon" title="Switch to system preference" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12c0-2.42-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12 20 8.69Z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/dgasmith/opt_einsum" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    dgasmith/opt_einsum
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Optimized Einsum" class="md-nav__button md-logo" aria-label="Optimized Einsum" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Optimized Einsum
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/dgasmith/opt_einsum" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.5.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2024 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    dgasmith/opt_einsum
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Overview
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Getting Started
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Getting Started
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../getting_started/install/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Installing
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../getting_started/input_format/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Input Format
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../getting_started/backends/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Backends & GPU Support
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../getting_started/reusing_paths/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Reusing Paths
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../getting_started/sharing_intermediates/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Sharing Intermediates
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Path Information
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Path Information
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../paths/introduction/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Introduction
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../paths/optimal_path/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Optimal Path
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../paths/branching_path/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Branching Path
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../paths/greedy_path/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Greedy Path
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../paths/random_greedy_path/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Random-Greedy Path
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../paths/dp_path/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Dynamic Programming Path
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../paths/custom_paths/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Custom Path Optimizers
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  <span class="md-ellipsis">
    Examples
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/dask_reusing_intermediaries/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Reusing Intermediaries with Dask
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../examples/large_expr_with_greedy/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Large Expressions with Greedy
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    API Reference
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    API Reference
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.contract" class="md-nav__link">
    <span class="md-ellipsis">
      contract
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.contract_path" class="md-nav__link">
    <span class="md-ellipsis">
      contract_path
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.contract_expression" class="md-nav__link">
    <span class="md-ellipsis">
      contract_expression
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.ContractExpression" class="md-nav__link">
    <span class="md-ellipsis">
      ContractExpression
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.ContractExpression.__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.ContractExpression.evaluate_constants" class="md-nav__link">
    <span class="md-ellipsis">
      evaluate_constants
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.PathInfo" class="md-nav__link">
    <span class="md-ellipsis">
      PathInfo
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.parser.get_symbol" class="md-nav__link">
    <span class="md-ellipsis">
      get_symbol
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.sharing.shared_intermediates" class="md-nav__link">
    <span class="md-ellipsis">
      shared_intermediates
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.optimal" class="md-nav__link">
    <span class="md-ellipsis">
      optimal
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.greedy" class="md-nav__link">
    <span class="md-ellipsis">
      greedy
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.branch" class="md-nav__link">
    <span class="md-ellipsis">
      branch
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.PathOptimizer" class="md-nav__link">
    <span class="md-ellipsis">
      PathOptimizer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.BranchBound" class="md-nav__link">
    <span class="md-ellipsis">
      BranchBound
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.BranchBound.__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.BranchBound.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomOptimizer" class="md-nav__link">
    <span class="md-ellipsis">
      RandomOptimizer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomOptimizer.path" class="md-nav__link">
    <span class="md-ellipsis">
      path
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomGreedy" class="md-nav__link">
    <span class="md-ellipsis">
      RandomGreedy
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomGreedy.choose_fn" class="md-nav__link">
    <span class="md-ellipsis">
      choose_fn
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomGreedy.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.DynamicProgramming" class="md-nav__link">
    <span class="md-ellipsis">
      DynamicProgramming
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.DynamicProgramming.__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../changelog/" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Changelog
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.contract" class="md-nav__link">
    <span class="md-ellipsis">
      contract
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.contract_path" class="md-nav__link">
    <span class="md-ellipsis">
      contract_path
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.contract_expression" class="md-nav__link">
    <span class="md-ellipsis">
      contract_expression
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.ContractExpression" class="md-nav__link">
    <span class="md-ellipsis">
      ContractExpression
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.ContractExpression.__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.ContractExpression.evaluate_constants" class="md-nav__link">
    <span class="md-ellipsis">
      evaluate_constants
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.contract.PathInfo" class="md-nav__link">
    <span class="md-ellipsis">
      PathInfo
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.parser.get_symbol" class="md-nav__link">
    <span class="md-ellipsis">
      get_symbol
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.sharing.shared_intermediates" class="md-nav__link">
    <span class="md-ellipsis">
      shared_intermediates
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.optimal" class="md-nav__link">
    <span class="md-ellipsis">
      optimal
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.greedy" class="md-nav__link">
    <span class="md-ellipsis">
      greedy
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.branch" class="md-nav__link">
    <span class="md-ellipsis">
      branch
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.PathOptimizer" class="md-nav__link">
    <span class="md-ellipsis">
      PathOptimizer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.BranchBound" class="md-nav__link">
    <span class="md-ellipsis">
      BranchBound
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.BranchBound.__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.BranchBound.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomOptimizer" class="md-nav__link">
    <span class="md-ellipsis">
      RandomOptimizer
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomOptimizer.path" class="md-nav__link">
    <span class="md-ellipsis">
      path
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomGreedy" class="md-nav__link">
    <span class="md-ellipsis">
      RandomGreedy
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomGreedy.choose_fn" class="md-nav__link">
    <span class="md-ellipsis">
      choose_fn
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.path_random.RandomGreedy.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.DynamicProgramming" class="md-nav__link">
    <span class="md-ellipsis">
      DynamicProgramming
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#opt_einsum.paths.DynamicProgramming.__call__" class="md-nav__link">
    <span class="md-ellipsis">
      __call__
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
  


<h1 id="api-documentation">API Documentation</h1>
<h3 id="opt_einsumcontract"><code>opt_einsum.contract</code></h3>


<div class="doc doc-object doc-function">



<a id="opt_einsum.contract.contract"></a>
    <div class="doc doc-contents first">

      <p>Evaluates the Einstein summation convention on the operands. A drop in
replacement for NumPy's einsum function that optimizes the order of contraction
to reduce overall scaling at the cost of several intermediate arrays.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>subscripts</code></td>
            <td>
                  <code><span title="typing.Union">Union</span>[str, <span title="opt_einsum.typing.ArrayType">ArrayType</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifies the subscripts for summation.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>*operands</code></td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="opt_einsum.typing.ArrayType">ArrayType</span>, <span title="typing.Collection">Collection</span>[int]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>These are the arrays for the operation.</p>
              </div>
            </td>
            <td>
                  <code>()</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>out</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="opt_einsum.typing.ArrayType">ArrayType</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A output array in which set the resulting output.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>dtype</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[str]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The dtype of the given contraction, see np.einsum.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>order</code></td>
            <td>
                  <code><span title="opt_einsum.contract._OrderKACF">_OrderKACF</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The order of the resulting contraction, see np.einsum.</p>
              </div>
            </td>
            <td>
                  <code>&#39;K&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>casting</code></td>
            <td>
                  <code><span title="opt_einsum.contract._Casting">_Casting</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The casting procedure for operations of different dtype, see np.einsum.</p>
              </div>
            </td>
            <td>
                  <code>&#39;safe&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>use_blas</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Do you use BLAS for valid operations, may use extra memory for more intermediates.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>optimize</code></td>
            <td>
                  <code><span title="opt_einsum.typing.OptimizeKind">OptimizeKind</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <ul>
<li>Choose the type of path the contraction will be optimized with</li>
<li>if a list is given uses this as the path.</li>
<li><code>'optimal'</code> An algorithm that explores all possible ways of
contracting the listed tensors. Scales factorially with the number of
terms in the contraction.</li>
<li><code>'dp'</code> A faster (but essentially optimal) algorithm that uses
dynamic programming to exhaustively search all contraction paths
without outer-products.</li>
<li><code>'greedy'</code> An cheap algorithm that heuristically chooses the best
pairwise contraction at each step. Scales linearly in the number of
terms in the contraction.</li>
<li><code>'random-greedy'</code> Run a randomized version of the greedy algorithm
32 times and pick the best path.</li>
<li><code>'random-greedy-128'</code> Run a randomized version of the greedy
algorithm 128 times and pick the best path.</li>
<li><code>'branch-all'</code> An algorithm like optimal but that restricts itself
to searching 'likely' paths. Still scales factorially.</li>
<li><code>'branch-2'</code> An even more restricted version of 'branch-all' that
only searches the best two options at each step. Scales exponentially
with the number of terms in the contraction.</li>
<li><code>'auto'</code> Choose the best of the above algorithms whilst aiming to
keep the path finding time below 1ms.</li>
<li><code>'auto-hq'</code> Aim for a high quality contraction, choosing the best
of the above algorithms whilst aiming to keep the path finding time
below 1sec.</li>
</ul>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>memory_limit</code></td>
            <td>
                  <code><span title="opt_einsum.contract._MemoryLimit">_MemoryLimit</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <ul>
<li>Give the upper bound of the largest intermediate tensor contract will build.</li>
<li>None or -1 means there is no limit.</li>
<li><code>max_input</code> means the limit is set as largest input tensor.</li>
<li>A positive integer is taken as an explicit limit on the number of elements.</li>
</ul>
<p>The default is None. Note that imposing a limit can make contractions
exponentially slower to perform.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>backend</code></td>
            <td>
                  <code><span title="opt_einsum.typing.BackendType">BackendType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Which library to use to perform the required <code>tensordot</code>, <code>transpose</code>
and <code>einsum</code> calls. Should match the types of arrays supplied, See
<code>contract_expression</code> for generating expressions which convert
numpy arrays to and from the backend library automatically.</p>
              </div>
            </td>
            <td>
                  <code>&#39;auto&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="opt_einsum.typing.ArrayType">ArrayType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The result of the einsum expression.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <p>This function should produce a result identical to that of NumPy's einsum
function. The primary difference is <code>contract</code> will attempt to form
intermediates which reduce the overall scaling of the given einsum contraction.
By default the worst intermediate formed will be equal to that of the largest
input array. For large einsum expressions with many input arrays this can
provide arbitrarily large (1000 fold+) speed improvements.</p>
<p>For contractions with just two tensors this function will attempt to use
NumPy's built-in BLAS functionality to ensure that the given operation is
performed optimally. When NumPy is linked to a threaded BLAS, potential
speedups are on the order of 20-100 for a six core machine.</p>
</details>
            <details class="quote">
              <summary>Source code in <code>opt_einsum/contract.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span>
<span class="normal">584</span>
<span class="normal">585</span>
<span class="normal">586</span>
<span class="normal">587</span>
<span class="normal">588</span>
<span class="normal">589</span>
<span class="normal">590</span>
<span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">contract</span><span class="p">(</span>
    <span class="n">subscripts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayType</span><span class="p">],</span>
    <span class="o">*</span><span class="n">operands</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">,</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="n">_OrderKACF</span> <span class="o">=</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span>
    <span class="n">casting</span><span class="p">:</span> <span class="n">_Casting</span> <span class="o">=</span> <span class="s2">&quot;safe&quot;</span><span class="p">,</span>
    <span class="n">use_blas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">optimize</span><span class="p">:</span> <span class="n">OptimizeKind</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">memory_limit</span><span class="p">:</span> <span class="n">_MemoryLimit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">backend</span><span class="p">:</span> <span class="n">BackendType</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates the Einstein summation convention on the operands. A drop in</span>
<span class="sd">    replacement for NumPy&#39;s einsum function that optimizes the order of contraction</span>
<span class="sd">    to reduce overall scaling at the cost of several intermediate arrays.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        subscripts: Specifies the subscripts for summation.</span>
<span class="sd">        *operands: These are the arrays for the operation.</span>
<span class="sd">        out: A output array in which set the resulting output.</span>
<span class="sd">        dtype: The dtype of the given contraction, see np.einsum.</span>
<span class="sd">        order: The order of the resulting contraction, see np.einsum.</span>
<span class="sd">        casting: The casting procedure for operations of different dtype, see np.einsum.</span>
<span class="sd">        use_blas: Do you use BLAS for valid operations, may use extra memory for more intermediates.</span>
<span class="sd">        optimize:- Choose the type of path the contraction will be optimized with</span>
<span class="sd">            - if a list is given uses this as the path.</span>
<span class="sd">            - `&#39;optimal&#39;` An algorithm that explores all possible ways of</span>
<span class="sd">            contracting the listed tensors. Scales factorially with the number of</span>
<span class="sd">            terms in the contraction.</span>
<span class="sd">            - `&#39;dp&#39;` A faster (but essentially optimal) algorithm that uses</span>
<span class="sd">            dynamic programming to exhaustively search all contraction paths</span>
<span class="sd">            without outer-products.</span>
<span class="sd">            - `&#39;greedy&#39;` An cheap algorithm that heuristically chooses the best</span>
<span class="sd">            pairwise contraction at each step. Scales linearly in the number of</span>
<span class="sd">            terms in the contraction.</span>
<span class="sd">            - `&#39;random-greedy&#39;` Run a randomized version of the greedy algorithm</span>
<span class="sd">            32 times and pick the best path.</span>
<span class="sd">            - `&#39;random-greedy-128&#39;` Run a randomized version of the greedy</span>
<span class="sd">            algorithm 128 times and pick the best path.</span>
<span class="sd">            - `&#39;branch-all&#39;` An algorithm like optimal but that restricts itself</span>
<span class="sd">            to searching &#39;likely&#39; paths. Still scales factorially.</span>
<span class="sd">            - `&#39;branch-2&#39;` An even more restricted version of &#39;branch-all&#39; that</span>
<span class="sd">            only searches the best two options at each step. Scales exponentially</span>
<span class="sd">            with the number of terms in the contraction.</span>
<span class="sd">            - `&#39;auto&#39;` Choose the best of the above algorithms whilst aiming to</span>
<span class="sd">            keep the path finding time below 1ms.</span>
<span class="sd">            - `&#39;auto-hq&#39;` Aim for a high quality contraction, choosing the best</span>
<span class="sd">            of the above algorithms whilst aiming to keep the path finding time</span>
<span class="sd">            below 1sec.</span>

<span class="sd">        memory_limit:- Give the upper bound of the largest intermediate tensor contract will build.</span>
<span class="sd">            - None or -1 means there is no limit.</span>
<span class="sd">            - `max_input` means the limit is set as largest input tensor.</span>
<span class="sd">            - A positive integer is taken as an explicit limit on the number of elements.</span>

<span class="sd">            The default is None. Note that imposing a limit can make contractions</span>
<span class="sd">            exponentially slower to perform.</span>

<span class="sd">        backend: Which library to use to perform the required ``tensordot``, ``transpose``</span>
<span class="sd">            and ``einsum`` calls. Should match the types of arrays supplied, See</span>
<span class="sd">            `contract_expression` for generating expressions which convert</span>
<span class="sd">            numpy arrays to and from the backend library automatically.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The result of the einsum expression.</span>

<span class="sd">    Notes:</span>
<span class="sd">        This function should produce a result identical to that of NumPy&#39;s einsum</span>
<span class="sd">        function. The primary difference is ``contract`` will attempt to form</span>
<span class="sd">        intermediates which reduce the overall scaling of the given einsum contraction.</span>
<span class="sd">        By default the worst intermediate formed will be equal to that of the largest</span>
<span class="sd">        input array. For large einsum expressions with many input arrays this can</span>
<span class="sd">        provide arbitrarily large (1000 fold+) speed improvements.</span>

<span class="sd">        For contractions with just two tensors this function will attempt to use</span>
<span class="sd">        NumPy&#39;s built-in BLAS functionality to ensure that the given operation is</span>
<span class="sd">        performed optimally. When NumPy is linked to a threaded BLAS, potential</span>
<span class="sd">        speedups are on the order of 20-100 for a six core machine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">optimize</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">optimize</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>

    <span class="n">operands_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">subscripts</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span>
    <span class="n">einsum_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;out&quot;</span><span class="p">:</span> <span class="n">out</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="n">order</span><span class="p">,</span> <span class="s2">&quot;casting&quot;</span><span class="p">:</span> <span class="n">casting</span><span class="p">}</span>

    <span class="c1"># If no optimization, run pure einsum</span>
    <span class="k">if</span> <span class="n">optimize</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_einsum</span><span class="p">(</span><span class="o">*</span><span class="n">operands_list</span><span class="p">,</span> <span class="o">**</span><span class="n">einsum_kwargs</span><span class="p">)</span>

    <span class="c1"># Grab non-einsum kwargs</span>
    <span class="n">gen_expression</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_gen_expression&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">constants_dict</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_constants_dict&quot;</span><span class="p">,</span> <span class="p">{})</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not understand the following kwargs: </span><span class="si">{</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gen_expression</span><span class="p">:</span>
        <span class="n">full_str</span> <span class="o">=</span> <span class="n">operands_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Build the contraction list and operand</span>
    <span class="n">contraction_list</span><span class="p">:</span> <span class="n">ContractionListType</span>
    <span class="n">operands</span><span class="p">,</span> <span class="n">contraction_list</span> <span class="o">=</span> <span class="n">contract_path</span><span class="p">(</span>  <span class="c1"># type: ignore</span>
        <span class="o">*</span><span class="n">operands_list</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">,</span> <span class="n">memory_limit</span><span class="o">=</span><span class="n">memory_limit</span><span class="p">,</span> <span class="n">einsum_call</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_blas</span><span class="o">=</span><span class="n">use_blas</span>
    <span class="p">)</span>

    <span class="c1"># check if performing contraction or just building expression</span>
    <span class="k">if</span> <span class="n">gen_expression</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ContractExpression</span><span class="p">(</span><span class="n">full_str</span><span class="p">,</span> <span class="n">contraction_list</span><span class="p">,</span> <span class="n">constants_dict</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_core_contract</span><span class="p">(</span>
        <span class="n">operands</span><span class="p">,</span> <span class="n">contraction_list</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="n">casting</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h3 id="opt_einsumcontract_path"><code>opt_einsum.contract_path</code></h3>


<div class="doc doc-object doc-function">



<a id="opt_einsum.contract.contract_path"></a>
    <div class="doc doc-contents first">

      <p>Find a contraction order <code>path</code>, without performing the contraction.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>subscripts</code></td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifies the subscripts for summation.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>*operands</code></td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>These are the arrays for the operation.</p>
              </div>
            </td>
            <td>
                  <code>()</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>use_blas</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Do you use BLAS for valid operations, may use extra memory for more intermediates.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>optimize</code></td>
            <td>
                  <code><span title="opt_einsum.typing.OptimizeKind">OptimizeKind</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Choose the type of path the contraction will be optimized with.
- if a list is given uses this as the path.
- <code>'optimal'</code> An algorithm that explores all possible ways of
contracting the listed tensors. Scales factorially with the number of
terms in the contraction.
- <code>'dp'</code> A faster (but essentially optimal) algorithm that uses
dynamic programming to exhaustively search all contraction paths
without outer-products.
- <code>'greedy'</code> An cheap algorithm that heuristically chooses the best
pairwise contraction at each step. Scales linearly in the number of
terms in the contraction.
- <code>'random-greedy'</code> Run a randomized version of the greedy algorithm
32 times and pick the best path.
- <code>'random-greedy-128'</code> Run a randomized version of the greedy
algorithm 128 times and pick the best path.
- <code>'branch-all'</code> An algorithm like optimal but that restricts itself
to searching 'likely' paths. Still scales factorially.
- <code>'branch-2'</code> An even more restricted version of 'branch-all' that
only searches the best two options at each step. Scales exponentially
with the number of terms in the contraction.
- <code>'auto'</code> Choose the best of the above algorithms whilst aiming to
keep the path finding time below 1ms.
- <code>'auto-hq'</code> Aim for a high quality contraction, choosing the best
of the above algorithms whilst aiming to keep the path finding time
below 1sec.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>memory_limit</code></td>
            <td>
                  <code><span title="opt_einsum.contract._MemoryLimit">_MemoryLimit</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Give the upper bound of the largest intermediate tensor contract will build.
- None or -1 means there is no limit
- <code>max_input</code> means the limit is set as largest input tensor
- a positive integer is taken as an explicit limit on the number of elements</p>
<p>The default is None. Note that imposing a limit can make contractions
exponentially slower to perform.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>shapes</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether <code>contract_path</code> should assume arrays (the default) or array shapes have been supplied.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>
      <p>Returns:
      path: The optimized einsum contraciton path
      PathInfo: A printable object containing various information about the path found.</p>
<p>Notes:
      The resulting path indicates which terms of the input contraction should be
      contracted first, the result of this contraction is then appended to the end of
      the contraction list.</p>
<p>Examples:
      We can begin with a chain dot example. In this case, it is optimal to
      contract the b and c tensors represented by the first element of the path (1,
      2). The resulting tensor is added to the end of the contraction and the
      remaining contraction, <code>(0, 1)</code>, is then executed.</p>
<div class="highlight"><pre><span></span><code><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">path_info</span> <span class="o">=</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span><span class="p">(</span><span class="s1">&#39;ij,jk,kl-&gt;il&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">#&gt; [(1, 2), (0, 1)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1">#&gt;   Complete contraction:  ij,jk,kl-&gt;il</span>
<span class="c1">#&gt;          Naive scaling:  4</span>
<span class="c1">#&gt;      Optimized scaling:  3</span>
<span class="c1">#&gt;       Naive FLOP count:  1.600e+02</span>
<span class="c1">#&gt;   Optimized FLOP count:  5.600e+01</span>
<span class="c1">#&gt;    Theoretical speedup:  2.857</span>
<span class="c1">#&gt;   Largest intermediate:  4.000e+00 elements</span>
<span class="c1">#&gt; -------------------------------------------------------------------------</span>
<span class="c1">#&gt; scaling                  current                                remaining</span>
<span class="c1">#&gt; -------------------------------------------------------------------------</span>
<span class="c1">#&gt;    3                   kl,jk-&gt;jl                                ij,jl-&gt;il</span>
<span class="c1">#&gt;    3                   jl,ij-&gt;il                                   il-&gt;il</span>
</code></pre></div>
<p>A more complex index transformation example.</p>
<div class="highlight"><pre><span></span><code><span class="n">I</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">path_info</span> <span class="o">=</span> <span class="n">oe</span><span class="o">.</span><span class="n">contract_path</span><span class="p">(</span><span class="s1">&#39;ea,fb,abcd,gc,hd-&gt;efgh&#39;</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1">#&gt; [(0, 2), (0, 3), (0, 2), (0, 1)]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">path_info</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1">#&gt;   Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh</span>
<span class="c1">#&gt;          Naive scaling:  8</span>
<span class="c1">#&gt;      Optimized scaling:  5</span>
<span class="c1">#&gt;       Naive FLOP count:  8.000e+08</span>
<span class="c1">#&gt;   Optimized FLOP count:  8.000e+05</span>
<span class="c1">#&gt;    Theoretical speedup:  1000.000</span>
<span class="c1">#&gt;   Largest intermediate:  1.000e+04 elements</span>
<span class="c1">#&gt; --------------------------------------------------------------------------</span>
<span class="c1">#&gt; scaling                  current                                remaining</span>
<span class="c1">#&gt; --------------------------------------------------------------------------</span>
<span class="c1">#&gt;    5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh</span>
<span class="c1">#&gt;    5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh</span>
<span class="c1">#&gt;    5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh</span>
<span class="c1">#&gt;    5               defg,hd-&gt;efgh                               efgh-&gt;efgh</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/contract.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">contract_path</span><span class="p">(</span>
    <span class="n">subscripts</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="o">*</span><span class="n">operands</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="n">use_blas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">optimize</span><span class="p">:</span> <span class="n">OptimizeKind</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">memory_limit</span><span class="p">:</span> <span class="n">_MemoryLimit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">shapes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">PathType</span><span class="p">,</span> <span class="n">PathInfo</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">      Find a contraction order `path`, without performing the contraction.</span>

<span class="sd">    Parameters:</span>
<span class="sd">          subscripts: Specifies the subscripts for summation.</span>
<span class="sd">          *operands: These are the arrays for the operation.</span>
<span class="sd">          use_blas: Do you use BLAS for valid operations, may use extra memory for more intermediates.</span>
<span class="sd">          optimize: Choose the type of path the contraction will be optimized with.</span>
<span class="sd">                - if a list is given uses this as the path.</span>
<span class="sd">                - `&#39;optimal&#39;` An algorithm that explores all possible ways of</span>
<span class="sd">                contracting the listed tensors. Scales factorially with the number of</span>
<span class="sd">                terms in the contraction.</span>
<span class="sd">                - `&#39;dp&#39;` A faster (but essentially optimal) algorithm that uses</span>
<span class="sd">                dynamic programming to exhaustively search all contraction paths</span>
<span class="sd">                without outer-products.</span>
<span class="sd">                - `&#39;greedy&#39;` An cheap algorithm that heuristically chooses the best</span>
<span class="sd">                pairwise contraction at each step. Scales linearly in the number of</span>
<span class="sd">                terms in the contraction.</span>
<span class="sd">                - `&#39;random-greedy&#39;` Run a randomized version of the greedy algorithm</span>
<span class="sd">                32 times and pick the best path.</span>
<span class="sd">                - `&#39;random-greedy-128&#39;` Run a randomized version of the greedy</span>
<span class="sd">                algorithm 128 times and pick the best path.</span>
<span class="sd">                - `&#39;branch-all&#39;` An algorithm like optimal but that restricts itself</span>
<span class="sd">                to searching &#39;likely&#39; paths. Still scales factorially.</span>
<span class="sd">                - `&#39;branch-2&#39;` An even more restricted version of &#39;branch-all&#39; that</span>
<span class="sd">                only searches the best two options at each step. Scales exponentially</span>
<span class="sd">                with the number of terms in the contraction.</span>
<span class="sd">                - `&#39;auto&#39;` Choose the best of the above algorithms whilst aiming to</span>
<span class="sd">                keep the path finding time below 1ms.</span>
<span class="sd">                - `&#39;auto-hq&#39;` Aim for a high quality contraction, choosing the best</span>
<span class="sd">                of the above algorithms whilst aiming to keep the path finding time</span>
<span class="sd">                below 1sec.</span>

<span class="sd">          memory_limit: Give the upper bound of the largest intermediate tensor contract will build.</span>
<span class="sd">                - None or -1 means there is no limit</span>
<span class="sd">                - `max_input` means the limit is set as largest input tensor</span>
<span class="sd">                - a positive integer is taken as an explicit limit on the number of elements</span>

<span class="sd">                The default is None. Note that imposing a limit can make contractions</span>
<span class="sd">                exponentially slower to perform.</span>

<span class="sd">          shapes: Whether ``contract_path`` should assume arrays (the default) or array shapes have been supplied.</span>

<span class="sd">      Returns:</span>
<span class="sd">          path: The optimized einsum contraciton path</span>
<span class="sd">          PathInfo: A printable object containing various information about the path found.</span>

<span class="sd">      Notes:</span>
<span class="sd">          The resulting path indicates which terms of the input contraction should be</span>
<span class="sd">          contracted first, the result of this contraction is then appended to the end of</span>
<span class="sd">          the contraction list.</span>

<span class="sd">      Examples:</span>
<span class="sd">          We can begin with a chain dot example. In this case, it is optimal to</span>
<span class="sd">          contract the b and c tensors represented by the first element of the path (1,</span>
<span class="sd">          2). The resulting tensor is added to the end of the contraction and the</span>
<span class="sd">          remaining contraction, `(0, 1)`, is then executed.</span>

<span class="sd">      ```python</span>
<span class="sd">      a = np.random.rand(2, 2)</span>
<span class="sd">      b = np.random.rand(2, 5)</span>
<span class="sd">      c = np.random.rand(5, 2)</span>
<span class="sd">      path_info = opt_einsum.contract_path(&#39;ij,jk,kl-&gt;il&#39;, a, b, c)</span>
<span class="sd">      print(path_info[0])</span>
<span class="sd">      #&gt; [(1, 2), (0, 1)]</span>
<span class="sd">      print(path_info[1])</span>
<span class="sd">      #&gt;   Complete contraction:  ij,jk,kl-&gt;il</span>
<span class="sd">      #&gt;          Naive scaling:  4</span>
<span class="sd">      #&gt;      Optimized scaling:  3</span>
<span class="sd">      #&gt;       Naive FLOP count:  1.600e+02</span>
<span class="sd">      #&gt;   Optimized FLOP count:  5.600e+01</span>
<span class="sd">      #&gt;    Theoretical speedup:  2.857</span>
<span class="sd">      #&gt;   Largest intermediate:  4.000e+00 elements</span>
<span class="sd">      #&gt; -------------------------------------------------------------------------</span>
<span class="sd">      #&gt; scaling                  current                                remaining</span>
<span class="sd">      #&gt; -------------------------------------------------------------------------</span>
<span class="sd">      #&gt;    3                   kl,jk-&gt;jl                                ij,jl-&gt;il</span>
<span class="sd">      #&gt;    3                   jl,ij-&gt;il                                   il-&gt;il</span>
<span class="sd">      ```</span>

<span class="sd">      A more complex index transformation example.</span>

<span class="sd">      ```python</span>
<span class="sd">      I = np.random.rand(10, 10, 10, 10)</span>
<span class="sd">      C = np.random.rand(10, 10)</span>
<span class="sd">      path_info = oe.contract_path(&#39;ea,fb,abcd,gc,hd-&gt;efgh&#39;, C, C, I, C, C)</span>

<span class="sd">      print(path_info[0])</span>
<span class="sd">      #&gt; [(0, 2), (0, 3), (0, 2), (0, 1)]</span>
<span class="sd">      print(path_info[1])</span>
<span class="sd">      #&gt;   Complete contraction:  ea,fb,abcd,gc,hd-&gt;efgh</span>
<span class="sd">      #&gt;          Naive scaling:  8</span>
<span class="sd">      #&gt;      Optimized scaling:  5</span>
<span class="sd">      #&gt;       Naive FLOP count:  8.000e+08</span>
<span class="sd">      #&gt;   Optimized FLOP count:  8.000e+05</span>
<span class="sd">      #&gt;    Theoretical speedup:  1000.000</span>
<span class="sd">      #&gt;   Largest intermediate:  1.000e+04 elements</span>
<span class="sd">      #&gt; --------------------------------------------------------------------------</span>
<span class="sd">      #&gt; scaling                  current                                remaining</span>
<span class="sd">      #&gt; --------------------------------------------------------------------------</span>
<span class="sd">      #&gt;    5               abcd,ea-&gt;bcde                      fb,gc,hd,bcde-&gt;efgh</span>
<span class="sd">      #&gt;    5               bcde,fb-&gt;cdef                         gc,hd,cdef-&gt;efgh</span>
<span class="sd">      #&gt;    5               cdef,gc-&gt;defg                            hd,defg-&gt;efgh</span>
<span class="sd">      #&gt;    5               defg,hd-&gt;efgh                               efgh-&gt;efgh</span>
<span class="sd">      ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">optimize</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">optimize</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>

    <span class="c1"># Hidden option, only einsum should call this</span>
    <span class="n">einsum_call_arg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;einsum_call&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Did not understand the following kwargs: </span><span class="si">{</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Python side parsing</span>
    <span class="n">operands_</span> <span class="o">=</span> <span class="p">[</span><span class="n">subscripts</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">operands</span><span class="p">)</span>
    <span class="n">input_subscripts</span><span class="p">,</span> <span class="n">output_subscript</span><span class="p">,</span> <span class="n">operands_prepped</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_einsum_input</span><span class="p">(</span><span class="n">operands_</span><span class="p">,</span> <span class="n">shapes</span><span class="o">=</span><span class="n">shapes</span><span class="p">)</span>

    <span class="c1"># Build a few useful list and sets</span>
    <span class="n">input_list</span> <span class="o">=</span> <span class="n">input_subscripts</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="n">input_sets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">input_list</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">shapes</span><span class="p">:</span>
        <span class="n">input_shapes</span> <span class="o">=</span> <span class="n">operands_prepped</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">operands_prepped</span><span class="p">]</span>
    <span class="n">output_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">output_subscript</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">input_subscripts</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

    <span class="c1"># Get length of each unique dimension and ensure all dimensions are correct</span>
    <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">tnum</span><span class="p">,</span> <span class="n">term</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">input_list</span><span class="p">):</span>
        <span class="n">sh</span> <span class="o">=</span> <span class="n">input_shapes</span><span class="p">[</span><span class="n">tnum</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Einstein sum subscript &#39;</span><span class="si">{}</span><span class="s2">&#39; does not contain the &quot;</span>
                <span class="s2">&quot;correct number of indices for operand </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">input_list</span><span class="p">[</span><span class="n">tnum</span><span class="p">],</span> <span class="n">tnum</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">for</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">char</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">term</span><span class="p">):</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sh</span><span class="p">[</span><span class="n">cnum</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">size_dict</span><span class="p">:</span>
                <span class="c1"># For broadcasting cases we always want the largest dim size</span>
                <span class="k">if</span> <span class="n">size_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">size_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>
                <span class="k">elif</span> <span class="n">dim</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Size of label &#39;</span><span class="si">{}</span><span class="s2">&#39; for operand </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">) does not match previous &quot;</span>
                        <span class="s2">&quot;terms (</span><span class="si">{}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">char</span><span class="p">,</span> <span class="n">tnum</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">[</span><span class="n">char</span><span class="p">],</span> <span class="n">dim</span><span class="p">)</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">size_dict</span><span class="p">[</span><span class="n">char</span><span class="p">]</span> <span class="o">=</span> <span class="n">dim</span>

    <span class="c1"># Compute size of each input array plus the output array</span>
    <span class="n">size_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">helpers</span><span class="o">.</span><span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">term</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">term</span> <span class="ow">in</span> <span class="n">input_list</span> <span class="o">+</span> <span class="p">[</span><span class="n">output_subscript</span><span class="p">]]</span>
    <span class="n">memory_arg</span> <span class="o">=</span> <span class="n">_choose_memory_arg</span><span class="p">(</span><span class="n">memory_limit</span><span class="p">,</span> <span class="n">size_list</span><span class="p">)</span>

    <span class="n">num_ops</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_list</span><span class="p">)</span>

    <span class="c1"># Compute naive cost</span>
    <span class="c1"># This is not quite right, need to look into exactly how einsum does this</span>
    <span class="c1"># indices_in_input = input_subscripts.replace(&#39;,&#39;, &#39;&#39;)</span>
    <span class="n">inner_product</span> <span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">input_sets</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="n">naive_cost</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">flop_count</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">inner_product</span><span class="p">,</span> <span class="n">num_ops</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

    <span class="c1"># Compute the path</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimize</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">paths</span><span class="o">.</span><span class="n">PathOptimizer</span><span class="p">)):</span>
        <span class="c1"># Custom path supplied</span>
        <span class="n">path_tuple</span><span class="p">:</span> <span class="n">PathType</span> <span class="o">=</span> <span class="n">optimize</span>  <span class="c1"># type: ignore</span>
    <span class="k">elif</span> <span class="n">num_ops</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Nothing to be optimized</span>
        <span class="n">path_tuple</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_ops</span><span class="p">))]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">optimize</span><span class="p">,</span> <span class="n">paths</span><span class="o">.</span><span class="n">PathOptimizer</span><span class="p">):</span>
        <span class="c1"># Custom path optimizer supplied</span>
        <span class="n">path_tuple</span> <span class="o">=</span> <span class="n">optimize</span><span class="p">(</span><span class="n">input_sets</span><span class="p">,</span> <span class="n">output_set</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="n">memory_arg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">path_optimizer</span> <span class="o">=</span> <span class="n">paths</span><span class="o">.</span><span class="n">get_path_fn</span><span class="p">(</span><span class="n">optimize</span><span class="p">)</span>
        <span class="n">path_tuple</span> <span class="o">=</span> <span class="n">path_optimizer</span><span class="p">(</span><span class="n">input_sets</span><span class="p">,</span> <span class="n">output_set</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="n">memory_arg</span><span class="p">)</span>

    <span class="n">cost_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">scale_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">size_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">contraction_list</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Build contraction tuple (positions, gemm, einsum_str, remaining)</span>
    <span class="k">for</span> <span class="n">cnum</span><span class="p">,</span> <span class="n">contract_inds</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">path_tuple</span><span class="p">):</span>
        <span class="c1"># Make sure we remove inds from right to left</span>
        <span class="n">contract_inds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">contract_inds</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

        <span class="n">contract_tuple</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">find_contraction</span><span class="p">(</span><span class="n">contract_inds</span><span class="p">,</span> <span class="n">input_sets</span><span class="p">,</span> <span class="n">output_set</span><span class="p">)</span>
        <span class="n">out_inds</span><span class="p">,</span> <span class="n">input_sets</span><span class="p">,</span> <span class="n">idx_removed</span><span class="p">,</span> <span class="n">idx_contract</span> <span class="o">=</span> <span class="n">contract_tuple</span>

        <span class="c1"># Compute cost, scale, and size</span>
        <span class="n">cost</span> <span class="o">=</span> <span class="n">helpers</span><span class="o">.</span><span class="n">flop_count</span><span class="p">(</span><span class="n">idx_contract</span><span class="p">,</span> <span class="nb">bool</span><span class="p">(</span><span class="n">idx_removed</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">contract_inds</span><span class="p">),</span> <span class="n">size_dict</span><span class="p">)</span>
        <span class="n">cost_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
        <span class="n">scale_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_contract</span><span class="p">))</span>
        <span class="n">size_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">helpers</span><span class="o">.</span><span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">out_inds</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">))</span>

        <span class="n">tmp_inputs</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">contract_inds</span><span class="p">]</span>
        <span class="n">tmp_shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">input_shapes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">contract_inds</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">use_blas</span><span class="p">:</span>
            <span class="n">do_blas</span> <span class="o">=</span> <span class="n">blas</span><span class="o">.</span><span class="n">can_blas</span><span class="p">(</span><span class="n">tmp_inputs</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out_inds</span><span class="p">),</span> <span class="n">idx_removed</span><span class="p">,</span> <span class="n">tmp_shapes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">do_blas</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Last contraction</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cnum</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">path_tuple</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">idx_result</span> <span class="o">=</span> <span class="n">output_subscript</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># use tensordot order to minimize transpositions</span>
            <span class="n">all_input_inds</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_inputs</span><span class="p">)</span>
            <span class="n">idx_result</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">out_inds</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">all_input_inds</span><span class="o">.</span><span class="n">find</span><span class="p">))</span>

        <span class="n">shp_result</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">find_output_shape</span><span class="p">(</span><span class="n">tmp_inputs</span><span class="p">,</span> <span class="n">tmp_shapes</span><span class="p">,</span> <span class="n">idx_result</span><span class="p">)</span>

        <span class="n">input_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_result</span><span class="p">)</span>
        <span class="n">input_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shp_result</span><span class="p">)</span>

        <span class="n">einsum_str</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_inputs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="n">idx_result</span>

        <span class="c1"># for large expressions saving the remaining terms at each step can</span>
        <span class="c1"># incur a large memory footprint - and also be messy to print</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_list</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">20</span><span class="p">:</span>
            <span class="n">remaining</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">input_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">remaining</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">contraction</span> <span class="o">=</span> <span class="p">(</span><span class="n">contract_inds</span><span class="p">,</span> <span class="n">idx_removed</span><span class="p">,</span> <span class="n">einsum_str</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">do_blas</span><span class="p">)</span>
        <span class="n">contraction_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contraction</span><span class="p">)</span>

    <span class="n">opt_cost</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">cost_list</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">einsum_call_arg</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">operands_prepped</span><span class="p">,</span> <span class="n">contraction_list</span>  <span class="c1"># type: ignore</span>

    <span class="n">path_print</span> <span class="o">=</span> <span class="n">PathInfo</span><span class="p">(</span>
        <span class="n">contraction_list</span><span class="p">,</span>
        <span class="n">input_subscripts</span><span class="p">,</span>
        <span class="n">output_subscript</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">,</span>
        <span class="n">path_tuple</span><span class="p">,</span>
        <span class="n">scale_list</span><span class="p">,</span>
        <span class="n">naive_cost</span><span class="p">,</span>
        <span class="n">opt_cost</span><span class="p">,</span>
        <span class="n">size_list</span><span class="p">,</span>
        <span class="n">size_dict</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">path_tuple</span><span class="p">,</span> <span class="n">path_print</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h3 id="opt_einsumcontract_expression"><code>opt_einsum.contract_expression</code></h3>


<div class="doc doc-object doc-function">



<a id="opt_einsum.contract.contract_expression"></a>
    <div class="doc doc-contents first">

      <p>Generate a reusable expression for a given contraction with
specific shapes, which can, for example, be cached.</p>
<p>Parameters:</p>
<div class="codehilite"><pre><span></span><code><span class="n">subscripts</span><span class="o">:</span><span class="w"> </span><span class="n">Specifies</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">subscripts</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">summation</span><span class="p">.</span>
<span class="n">shapes</span><span class="o">:</span><span class="w"> </span><span class="n">Shapes</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">arrays</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">optimize</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">contraction</span><span class="w"> </span><span class="k">for</span><span class="p">.</span>
<span class="n">constants</span><span class="o">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">indices</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">any</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n n-Quoted">`shapes`</span><span class="p">,</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="k">case</span><span class="w"> </span><span class="n">the</span>
<span class="w">    </span><span class="n">actual</span><span class="w"> </span><span class="k">array</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">supplied</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">position</span><span class="w"> </span><span class="n">rather</span><span class="w"> </span><span class="k">than</span><span class="w"> </span><span class="n">just</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">shape</span><span class="p">.</span><span class="w"> </span><span class="k">If</span><span class="w"> </span><span class="n">these</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">specified</span><span class="p">,</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">parts</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">contraction</span>
<span class="w">    </span><span class="k">between</span><span class="w"> </span><span class="n">calls</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">reused</span><span class="p">.</span><span class="w"> </span><span class="n">Additionally</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">GPU</span><span class="o">-</span><span class="n">enabled</span><span class="w"> </span><span class="n">backend</span><span class="w"> </span><span class="k">is</span>
<span class="w">    </span><span class="n">used</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">example</span><span class="p">,</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">tensors</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">kept</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">GPU</span><span class="p">,</span>
<span class="w">    </span><span class="n">minimizing</span><span class="w"> </span><span class="n">transfers</span><span class="p">.</span>
<span class="n">kwargs</span><span class="o">:</span><span class="w"> </span><span class="n">Passed</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n n-Quoted">`contract_path`</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n n-Quoted">`einsum`</span><span class="p">.</span><span class="w"> </span><span class="n">See</span><span class="w"> </span><span class="n n-Quoted">`contract`</span><span class="p">.</span>
</code></pre></div>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="opt_einsum.contract.ContractExpression" href="#opt_einsum.contract.ContractExpression">ContractExpression</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Callable with signature <code>expr(*arrays, out=None, backend='numpy')</code> where the array's shapes should match <code>shapes</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
      <p>Notes:</p>
<div class="codehilite"><pre><span></span><code><span class="n">The</span><span class="w"> </span><span class="n n-Quoted">`out`</span><span class="w"> </span><span class="n">keyword</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">supplied</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">generated</span><span class="w"> </span><span class="n">expression</span>
<span class="n">rather</span><span class="w"> </span><span class="k">than</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">function</span><span class="p">.</span>
<span class="n">The</span><span class="w"> </span><span class="n n-Quoted">`backend`</span><span class="w"> </span><span class="n">keyword</span><span class="w"> </span><span class="n">argument</span><span class="w"> </span><span class="n">should</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">supplied</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">generated</span>
<span class="n">expression</span><span class="p">.</span><span class="w"> </span><span class="k">If</span><span class="w"> </span><span class="n">numpy</span><span class="w"> </span><span class="n">arrays</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">supplied</span><span class="p">,</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">possible</span><span class="w"> </span><span class="n">they</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span>
<span class="n">converted</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">back</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">correct</span><span class="w"> </span><span class="n">backend</span><span class="w"> </span><span class="k">array</span><span class="w"> </span><span class="k">type</span><span class="p">.</span>
<span class="n">The</span><span class="w"> </span><span class="k">generated</span><span class="w"> </span><span class="n">expression</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="k">work</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">any</span><span class="w"> </span><span class="n">arrays</span><span class="w"> </span><span class="n">which</span><span class="w"> </span><span class="n">have</span>
<span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="k">rank</span><span class="w"> </span><span class="p">(</span><span class="k">number</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">dimensions</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">original</span><span class="w"> </span><span class="n">shapes</span><span class="p">,</span><span class="w"> </span><span class="n">however</span><span class="p">,</span><span class="w"> </span><span class="k">if</span>
<span class="n">the</span><span class="w"> </span><span class="n">actual</span><span class="w"> </span><span class="n">sizes</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">different</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">expression</span><span class="w"> </span><span class="n">may</span><span class="w"> </span><span class="k">no</span><span class="w"> </span><span class="n">longer</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">optimal</span><span class="p">.</span>
<span class="n">Constant</span><span class="w"> </span><span class="n">operations</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">computed</span><span class="w"> </span><span class="n">upon</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">particular</span>
<span class="n">backend</span><span class="p">,</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">subsequently</span><span class="w"> </span><span class="n">reused</span><span class="p">.</span>
</code></pre></div>

<p>Examples:</p>
<p>Basic usage:</p>
<div class="highlight"><pre><span></span><code><span class="n">expr</span> <span class="o">=</span> <span class="n">contract_expression</span><span class="p">(</span><span class="s2">&quot;ab,bc-&gt;ac&quot;</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">#&gt; True</span>
</code></pre></div>
<p>Supply <code>a</code> as a constant:</p>
<div class="highlight"><pre><span></span><code><span class="n">expr</span> <span class="o">=</span> <span class="n">contract_expression</span><span class="p">(</span><span class="s2">&quot;ab,bc-&gt;ac&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">constants</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">expr</span>
<span class="c1">#&gt; &lt;ContractExpression(&#39;[ab],bc-&gt;ac&#39;, constants=[0])&gt;</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">expr</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="o">@</span> <span class="n">b</span><span class="p">)</span>
<span class="c1">#&gt; True</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/contract.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span>
<span class="normal">1031</span>
<span class="normal">1032</span>
<span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">contract_expression</span><span class="p">(</span>
    <span class="n">subscripts</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ArrayType</span><span class="p">,</span> <span class="n">TensorShapeType</span><span class="p">],</span>
    <span class="o">*</span><span class="n">shapes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">,</span> <span class="n">TensorShapeType</span><span class="p">,</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span>
    <span class="n">constants</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Collection</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_blas</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">optimize</span><span class="p">:</span> <span class="n">OptimizeKind</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">memory_limit</span><span class="p">:</span> <span class="n">_MemoryLimit</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ContractExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a reusable expression for a given contraction with</span>
<span class="sd">    specific shapes, which can, for example, be cached.</span>

<span class="sd">    Parameters:</span>

<span class="sd">        subscripts: Specifies the subscripts for summation.</span>
<span class="sd">        shapes: Shapes of the arrays to optimize the contraction for.</span>
<span class="sd">        constants: The indices of any constant arguments in `shapes`, in which case the</span>
<span class="sd">            actual array should be supplied at that position rather than just a</span>
<span class="sd">            shape. If these are specified, then constant parts of the contraction</span>
<span class="sd">            between calls will be reused. Additionally, if a GPU-enabled backend is</span>
<span class="sd">            used for example, then the constant tensors will be kept on the GPU,</span>
<span class="sd">            minimizing transfers.</span>
<span class="sd">        kwargs: Passed on to `contract_path` or `einsum`. See `contract`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Callable with signature `expr(*arrays, out=None, backend=&#39;numpy&#39;)` where the array&#39;s shapes should match `shapes`.</span>

<span class="sd">    Notes:</span>

<span class="sd">        The `out` keyword argument should be supplied to the generated expression</span>
<span class="sd">        rather than this function.</span>
<span class="sd">        The `backend` keyword argument should also be supplied to the generated</span>
<span class="sd">        expression. If numpy arrays are supplied, if possible they will be</span>
<span class="sd">        converted to and back from the correct backend array type.</span>
<span class="sd">        The generated expression will work with any arrays which have</span>
<span class="sd">        the same rank (number of dimensions) as the original shapes, however, if</span>
<span class="sd">        the actual sizes are different, the expression may no longer be optimal.</span>
<span class="sd">        Constant operations will be computed upon the first call with a particular</span>
<span class="sd">        backend, then subsequently reused.</span>

<span class="sd">    Examples:</span>

<span class="sd">    Basic usage:</span>

<span class="sd">    ```python</span>
<span class="sd">    expr = contract_expression(&quot;ab,bc-&gt;ac&quot;, (3, 4), (4, 5))</span>
<span class="sd">    a, b = np.random.rand(3, 4), np.random.rand(4, 5)</span>
<span class="sd">    c = expr(a, b)</span>
<span class="sd">    np.allclose(c, a @ b)</span>
<span class="sd">    #&gt; True</span>
<span class="sd">    ```</span>

<span class="sd">    Supply `a` as a constant:</span>

<span class="sd">    ```python</span>
<span class="sd">    expr = contract_expression(&quot;ab,bc-&gt;ac&quot;, a, (4, 5), constants=[0])</span>
<span class="sd">    expr</span>
<span class="sd">    #&gt; &lt;ContractExpression(&#39;[ab],bc-&gt;ac&#39;, constants=[0])&gt;</span>

<span class="sd">    c = expr(b)</span>
<span class="sd">    np.allclose(c, a @ b)</span>
<span class="sd">    #&gt; True</span>
<span class="sd">    ```</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">optimize</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Can only generate expressions for optimized contractions.&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="s2">&quot;backend&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39; should only be specified when calling a &quot;</span>
                <span class="s2">&quot;`ContractExpression`, not when building it.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">subscripts</span><span class="p">,</span> <span class="n">shapes</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">convert_interleaved_input</span><span class="p">((</span><span class="n">subscripts</span><span class="p">,)</span> <span class="o">+</span> <span class="n">shapes</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;_gen_expression&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># build dict of constant indices mapped to arrays</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="n">constants</span> <span class="ow">or</span> <span class="nb">tuple</span><span class="p">()</span>
    <span class="n">constants_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">shapes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">constants</span><span class="p">}</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;_constants_dict&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">constants_dict</span>

    <span class="c1"># apart from constant arguments, make dummy arrays</span>
    <span class="n">dummy_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">constants</span> <span class="k">else</span> <span class="n">shape_only</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">)]</span>  <span class="c1"># type: ignore</span>

    <span class="k">return</span> <span class="n">contract</span><span class="p">(</span>
        <span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">dummy_arrays</span><span class="p">,</span> <span class="n">use_blas</span><span class="o">=</span><span class="n">use_blas</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">,</span> <span class="n">memory_limit</span><span class="o">=</span><span class="n">memory_limit</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h3 id="opt_einsumcontractcontractexpression"><code>opt_einsum.contract.ContractExpression</code></h3>


<div class="doc doc-object doc-class">



<a id="opt_einsum.contract.ContractExpression"></a>
    <div class="doc doc-contents first">


      <p>Helper class for storing an explicit <code>contraction_list</code> which can
then be repeatedly called solely with the array arguments.</p>

              <details class="quote">
                <summary>Source code in <code>opt_einsum/contract.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span>
<span class="normal">831</span>
<span class="normal">832</span>
<span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span>
<span class="normal">860</span>
<span class="normal">861</span>
<span class="normal">862</span>
<span class="normal">863</span>
<span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span>
<span class="normal">942</span>
<span class="normal">943</span>
<span class="normal">944</span>
<span class="normal">945</span>
<span class="normal">946</span>
<span class="normal">947</span>
<span class="normal">948</span>
<span class="normal">949</span>
<span class="normal">950</span>
<span class="normal">951</span>
<span class="normal">952</span>
<span class="normal">953</span>
<span class="normal">954</span>
<span class="normal">955</span>
<span class="normal">956</span>
<span class="normal">957</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">ContractExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Helper class for storing an explicit ``contraction_list`` which can</span>
<span class="sd">    then be repeatedly called solely with the array arguments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">contraction</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">contraction_list</span><span class="p">:</span> <span class="n">ContractionListType</span><span class="p">,</span>
        <span class="n">constants_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ArrayType</span><span class="p">],</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">order</span><span class="p">:</span> <span class="n">_OrderKACF</span> <span class="o">=</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span>
        <span class="n">casting</span><span class="p">:</span> <span class="n">_Casting</span> <span class="o">=</span> <span class="s2">&quot;safe&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contraction_list</span> <span class="o">=</span> <span class="n">contraction_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">order</span> <span class="o">=</span> <span class="n">order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">casting</span> <span class="o">=</span> <span class="n">casting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contraction</span> <span class="o">=</span> <span class="n">format_const_einsum_str</span><span class="p">(</span><span class="n">contraction</span><span class="p">,</span> <span class="n">constants_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># need to know _full_num_args to parse constants with, and num_args to call with</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_num_args</span> <span class="o">=</span> <span class="n">contraction</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_num_args</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">constants_dict</span><span class="p">)</span>

        <span class="c1"># likewise need to know full contraction list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_full_contraction_list</span> <span class="o">=</span> <span class="n">contraction_list</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_constants_dict</span> <span class="o">=</span> <span class="n">constants_dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_evaluated_constants</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backend_expressions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">evaluate_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert any constant operands to the correct backend form, and</span>
<span class="sd">        perform as many contractions as possible to create a new list of</span>
<span class="sd">        operands, stored in ``self._evaluated_constants[backend]``. This also</span>
<span class="sd">        makes sure ``self.contraction_list`` only contains the remaining,</span>
<span class="sd">        non-const operations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># prepare a list of operands, with `None` for non-consts</span>
        <span class="n">tmp_const_ops</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_constants_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_num_args</span><span class="p">)]</span>
        <span class="n">backend</span> <span class="o">=</span> <span class="n">parse_backend</span><span class="p">(</span><span class="n">tmp_const_ops</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>

        <span class="c1"># get the new list of operands with constant operations performed, and remaining contractions</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_ops</span><span class="p">,</span> <span class="n">new_contraction_list</span> <span class="o">=</span> <span class="n">backends</span><span class="o">.</span><span class="n">evaluate_constants</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="n">tmp_const_ops</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">new_ops</span><span class="p">,</span> <span class="n">new_contraction_list</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_const_ops</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">evaluate_constants</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_evaluated_constants</span><span class="p">[</span><span class="n">backend</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contraction_list</span> <span class="o">=</span> <span class="n">new_contraction_list</span>

    <span class="k">def</span> <span class="nf">_get_evaluated_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve or generate the cached list of constant operators (mixed</span>
<span class="sd">        in with None representing non-consts) and the remaining contraction</span>
<span class="sd">        list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluated_constants</span><span class="p">[</span><span class="n">backend</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">evaluate_constants</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_evaluated_constants</span><span class="p">[</span><span class="n">backend</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_backend_expression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arrays</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">],</span> <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backend_expressions</span><span class="p">[</span><span class="n">backend</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="n">backends</span><span class="o">.</span><span class="n">build_expression</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backend_expressions</span><span class="p">[</span><span class="n">backend</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span>
            <span class="k">return</span> <span class="n">fn</span>

    <span class="k">def</span> <span class="nf">_contract</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arrays</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">],</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">evaluate_constants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The normal, core contraction.&quot;&quot;&quot;</span>
        <span class="n">contraction_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_contraction_list</span> <span class="k">if</span> <span class="n">evaluate_constants</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">contraction_list</span>

        <span class="k">return</span> <span class="n">_core_contract</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="n">arrays</span><span class="p">),</span>
            <span class="n">contraction_list</span><span class="p">,</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
            <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span>
            <span class="n">evaluate_constants</span><span class="o">=</span><span class="n">evaluate_constants</span><span class="p">,</span>
            <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="n">order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span>
            <span class="n">casting</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">casting</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_contract_with_conversion</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">arrays</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">],</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">],</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">evaluate_constants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Special contraction, i.e., contraction with a different backend</span>
<span class="sd">        but converting to and from that backend. Retrieves or generates a</span>
<span class="sd">        cached expression using ``arrays`` as templates, then calls it</span>
<span class="sd">        with ``arrays``.</span>

<span class="sd">        If ``evaluate_constants=True``, perform a partial contraction that</span>
<span class="sd">        prepares the constant tensors and operations with the right backend.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># convert consts to correct type &amp; find reduced contraction list</span>
        <span class="k">if</span> <span class="n">evaluate_constants</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">backends</span><span class="o">.</span><span class="n">evaluate_constants</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="n">arrays</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_backend_expression</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">backend</span><span class="p">)(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[()]</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">return</span> <span class="n">out</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">ArrayType</span><span class="p">,</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">ArrayType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
        <span class="n">evaluate_constants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate this expression with a set of arrays.</span>

<span class="sd">        Parameters:</span>
<span class="sd">            arrays: The arrays to supply as input to the expression.</span>
<span class="sd">            out: If specified, output the result into this array.</span>
<span class="sd">            backend: Perform the contraction with this backend library. If numpy arrays</span>
<span class="sd">                are supplied then try to convert them to and from the correct</span>
<span class="sd">                backend array type.</span>
<span class="sd">            evaluate_constants: Pre-evaluates constants with the appropriate backend.</span>

<span class="sd">        Returns:</span>
<span class="sd">            The contracted result.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">backend</span> <span class="o">=</span> <span class="n">parse_backend</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>

        <span class="n">correct_num_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_num_args</span> <span class="k">if</span> <span class="n">evaluate_constants</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_args</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">!=</span> <span class="n">correct_num_args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;This `ContractExpression` takes exactly </span><span class="si">{}</span><span class="s2"> array arguments &quot;</span>
                <span class="s2">&quot;but received </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_args</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constants_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">evaluate_constants</span><span class="p">:</span>
            <span class="c1"># fill in the missing non-constant terms with newly supplied arrays</span>
            <span class="n">ops_var</span><span class="p">,</span> <span class="n">ops_const</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">arrays</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_evaluated_constants</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
            <span class="n">ops</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">ops_var</span><span class="p">)</span> <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops_const</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="n">arrays</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Check if the backend requires special preparation / calling</span>
            <span class="c1">#   but also ignore non-numpy arrays -&gt; assume user wants same type back</span>
            <span class="k">if</span> <span class="n">backends</span><span class="o">.</span><span class="n">has_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;numpy&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_with_conversion</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">evaluate_constants</span><span class="o">=</span><span class="n">evaluate_constants</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">evaluate_constants</span><span class="o">=</span><span class="n">evaluate_constants</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="n">original_msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                <span class="s2">&quot;Internal error while evaluating `ContractExpression`. Note that few checks are performed&quot;</span>
                <span class="s2">&quot; - the number and rank of the array arguments must match the original expression. &quot;</span>
                <span class="s2">&quot;The internal error was: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">original_msg</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">err</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="k">raise</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constants_dict</span><span class="p">:</span>
            <span class="n">constants_repr</span> <span class="o">=</span> <span class="s2">&quot;, constants=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constants_dict</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">constants_repr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;&lt;ContractExpression(&#39;</span><span class="si">{}</span><span class="s2">&#39;</span><span class="si">{}</span><span class="s2">)&gt;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contraction</span><span class="p">,</span> <span class="n">constants_repr</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contraction_list</span><span class="p">):</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  </span><span class="si">{}</span><span class="s2">.  &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; [</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;order&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">order</span><span class="p">,</span> <span class="s2">&quot;casting&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">casting</span><span class="p">}</span>
            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">einsum_kwargs=</span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="opt_einsum.contract.ContractExpression.__call__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__call__</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">evaluate_constants</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

      <p>Evaluate this expression with a set of arrays.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>arrays</code></td>
            <td>
                  <code><span title="opt_einsum.typing.ArrayType">ArrayType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The arrays to supply as input to the expression.</p>
              </div>
            </td>
            <td>
                  <code>()</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>out</code></td>
            <td>
                  <code><span title="typing.Union">Union</span>[None, <span title="opt_einsum.typing.ArrayType">ArrayType</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If specified, output the result into this array.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>backend</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Perform the contraction with this backend library. If numpy arrays
are supplied then try to convert them to and from the correct
backend array type.</p>
              </div>
            </td>
            <td>
                  <code>&#39;auto&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>evaluate_constants</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Pre-evaluates constants with the appropriate backend.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="opt_einsum.typing.ArrayType">ArrayType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The contracted result.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/contract.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span>
<span class="normal">930</span>
<span class="normal">931</span>
<span class="normal">932</span>
<span class="normal">933</span>
<span class="normal">934</span>
<span class="normal">935</span>
<span class="normal">936</span>
<span class="normal">937</span>
<span class="normal">938</span>
<span class="normal">939</span>
<span class="normal">940</span>
<span class="normal">941</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="o">*</span><span class="n">arrays</span><span class="p">:</span> <span class="n">ArrayType</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="n">ArrayType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">backend</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">,</span>
    <span class="n">evaluate_constants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Evaluate this expression with a set of arrays.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        arrays: The arrays to supply as input to the expression.</span>
<span class="sd">        out: If specified, output the result into this array.</span>
<span class="sd">        backend: Perform the contraction with this backend library. If numpy arrays</span>
<span class="sd">            are supplied then try to convert them to and from the correct</span>
<span class="sd">            backend array type.</span>
<span class="sd">        evaluate_constants: Pre-evaluates constants with the appropriate backend.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The contracted result.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">backend</span> <span class="o">=</span> <span class="n">parse_backend</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>

    <span class="n">correct_num_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_full_num_args</span> <span class="k">if</span> <span class="n">evaluate_constants</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_args</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">!=</span> <span class="n">correct_num_args</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;This `ContractExpression` takes exactly </span><span class="si">{}</span><span class="s2"> array arguments &quot;</span>
            <span class="s2">&quot;but received </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_args</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constants_dict</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">evaluate_constants</span><span class="p">:</span>
        <span class="c1"># fill in the missing non-constant terms with newly supplied arrays</span>
        <span class="n">ops_var</span><span class="p">,</span> <span class="n">ops_const</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">arrays</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_evaluated_constants</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span>
        <span class="n">ops</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayType</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">ops_var</span><span class="p">)</span> <span class="k">if</span> <span class="n">op</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">op</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">ops_const</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="n">arrays</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Check if the backend requires special preparation / calling</span>
        <span class="c1">#   but also ignore non-numpy arrays -&gt; assume user wants same type back</span>
        <span class="k">if</span> <span class="n">backends</span><span class="o">.</span><span class="n">has_backend</span><span class="p">(</span><span class="n">backend</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">infer_backend</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;numpy&quot;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract_with_conversion</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">evaluate_constants</span><span class="o">=</span><span class="n">evaluate_constants</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contract</span><span class="p">(</span><span class="n">ops</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">evaluate_constants</span><span class="o">=</span><span class="n">evaluate_constants</span><span class="p">)</span>

    <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">original_msg</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">err</span><span class="o">.</span><span class="n">args</span><span class="p">)</span> <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">args</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Internal error while evaluating `ContractExpression`. Note that few checks are performed&quot;</span>
            <span class="s2">&quot; - the number and rank of the array arguments must match the original expression. &quot;</span>
            <span class="s2">&quot;The internal error was: &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">original_msg</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">err</span><span class="o">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">msg</span>
        <span class="k">raise</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="opt_einsum.contract.ContractExpression.evaluate_constants" class="doc doc-heading">
            <code class=" language-python"><span class="n">evaluate_constants</span><span class="p">(</span><span class="n">backend</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

      <p>Convert any constant operands to the correct backend form, and
perform as many contractions as possible to create a new list of
operands, stored in <code>self._evaluated_constants[backend]</code>. This also
makes sure <code>self.contraction_list</code> only contains the remaining,
non-const operations.</p>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/contract.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span>
<span class="normal">811</span>
<span class="normal">812</span>
<span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">evaluate_constants</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backend</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert any constant operands to the correct backend form, and</span>
<span class="sd">    perform as many contractions as possible to create a new list of</span>
<span class="sd">    operands, stored in ``self._evaluated_constants[backend]``. This also</span>
<span class="sd">    makes sure ``self.contraction_list`` only contains the remaining,</span>
<span class="sd">    non-const operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># prepare a list of operands, with `None` for non-consts</span>
    <span class="n">tmp_const_ops</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_constants_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_full_num_args</span><span class="p">)]</span>
    <span class="n">backend</span> <span class="o">=</span> <span class="n">parse_backend</span><span class="p">(</span><span class="n">tmp_const_ops</span><span class="p">,</span> <span class="n">backend</span><span class="p">)</span>

    <span class="c1"># get the new list of operands with constant operations performed, and remaining contractions</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">new_ops</span><span class="p">,</span> <span class="n">new_contraction_list</span> <span class="o">=</span> <span class="n">backends</span><span class="o">.</span><span class="n">evaluate_constants</span><span class="p">(</span><span class="n">backend</span><span class="p">,</span> <span class="n">tmp_const_ops</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">new_ops</span><span class="p">,</span> <span class="n">new_contraction_list</span> <span class="o">=</span> <span class="bp">self</span><span class="p">(</span><span class="o">*</span><span class="n">tmp_const_ops</span><span class="p">,</span> <span class="n">backend</span><span class="o">=</span><span class="n">backend</span><span class="p">,</span> <span class="n">evaluate_constants</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">_evaluated_constants</span><span class="p">[</span><span class="n">backend</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_ops</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">contraction_list</span> <span class="o">=</span> <span class="n">new_contraction_list</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h3 id="opt_einsumcontractpathinfo"><code>opt_einsum.contract.PathInfo</code></h3>


<div class="doc doc-object doc-class">



<a id="opt_einsum.contract.PathInfo"></a>
    <div class="doc doc-contents first">


      <p>A printable object to contain information about a contraction path.</p>

              <details class="quote">
                <summary>Source code in <code>opt_einsum/contract.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">PathInfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A printable object to contain information about a contraction path.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">contraction_list</span><span class="p">:</span> <span class="n">ContractionListType</span><span class="p">,</span>
        <span class="n">input_subscripts</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">output_subscript</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
        <span class="n">path</span><span class="p">:</span> <span class="n">PathType</span><span class="p">,</span>
        <span class="n">scale_list</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">naive_cost</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">opt_cost</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">size_list</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contraction_list</span> <span class="o">=</span> <span class="n">contraction_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_subscripts</span> <span class="o">=</span> <span class="n">input_subscripts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_subscript</span> <span class="o">=</span> <span class="n">output_subscript</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale_list</span> <span class="o">=</span> <span class="n">scale_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">naive_cost</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">naive_cost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">opt_cost</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">opt_cost</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">speedup</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">naive_cost</span> <span class="o">/</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_cost</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_list</span> <span class="o">=</span> <span class="n">size_list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_dict</span> <span class="o">=</span> <span class="n">size_dict</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">size_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">)</span> <span class="k">for</span> <span class="n">ks</span> <span class="ow">in</span> <span class="n">input_subscripts</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eq</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">-&gt;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">input_subscripts</span><span class="p">,</span> <span class="n">output_subscript</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">largest_intermediate</span> <span class="o">=</span> <span class="n">Decimal</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">size_list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Return the path along with a nice string representation</span>
        <span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;scaling&quot;</span><span class="p">,</span> <span class="s2">&quot;BLAS&quot;</span><span class="p">,</span> <span class="s2">&quot;current&quot;</span><span class="p">,</span> <span class="s2">&quot;remaining&quot;</span><span class="p">)</span>

        <span class="n">path_print</span> <span class="o">=</span> <span class="p">[</span>
            <span class="s2">&quot;  Complete contraction:  </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eq</span><span class="p">),</span>
            <span class="s2">&quot;         Naive scaling:  </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">indices</span><span class="p">)),</span>
            <span class="s2">&quot;     Optimized scaling:  </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scale_list</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
            <span class="s2">&quot;      Naive FLOP count:  </span><span class="si">{:.3e}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">naive_cost</span><span class="p">),</span>
            <span class="s2">&quot;  Optimized FLOP count:  </span><span class="si">{:.3e}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt_cost</span><span class="p">),</span>
            <span class="s2">&quot;   Theoretical speedup:  </span><span class="si">{:.3e}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">speedup</span><span class="p">),</span>
            <span class="s2">&quot;  Largest intermediate:  </span><span class="si">{:.3e}</span><span class="s2"> elements</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">largest_intermediate</span><span class="p">),</span>
            <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;</span><span class="si">{:&gt;6}</span><span class="s2"> </span><span class="si">{:&gt;11}</span><span class="s2"> </span><span class="si">{:&gt;22}</span><span class="s2"> </span><span class="si">{:&gt;37}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">),</span>
            <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">80</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">contraction</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contraction_list</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">einsum_str</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">do_blas</span> <span class="o">=</span> <span class="n">contraction</span>

            <span class="k">if</span> <span class="n">remaining</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">remaining_str</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-&gt;&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_subscript</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remaining_str</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span>
            <span class="n">size_remaining</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">56</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="mi">22</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">einsum_str</span><span class="p">)))</span>

            <span class="n">path_run</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">scale_list</span><span class="p">[</span><span class="n">n</span><span class="p">],</span>
                <span class="n">do_blas</span><span class="p">,</span>
                <span class="n">einsum_str</span><span class="p">,</span>
                <span class="n">remaining_str</span><span class="p">,</span>
                <span class="n">size_remaining</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">path_print</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{:&gt;4}</span><span class="s2"> </span><span class="si">{:&gt;14}</span><span class="s2"> </span><span class="si">{:&gt;22}</span><span class="s2">    {:&gt;</span><span class="si">{}</span><span class="s2">}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">path_run</span><span class="p">))</span>

        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path_print</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div><h3 id="opt_einsumget_symbol"><code>opt_einsum.get_symbol</code></h3>


<div class="doc doc-object doc-function">



<a id="opt_einsum.parser.get_symbol"></a>
    <div class="doc doc-contents first">

      <p>Get the symbol corresponding to int <code>i</code> - runs through the usual 52
letters before resorting to unicode characters, starting at <code>chr(192)</code> and skipping surrogates.</p>
<p><strong>Examples:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">get_symbol</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="c1">#&gt; &#39;c&#39;</span>

<span class="n">get_symbol</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="c1">#&gt; &#39;Ŕ&#39;</span>

<span class="n">get_symbol</span><span class="p">(</span><span class="mi">20000</span><span class="p">)</span>
<span class="c1">#&gt; &#39;京&#39;</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/parser.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">get_symbol</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the symbol corresponding to int ``i`` - runs through the usual 52</span>
<span class="sd">    letters before resorting to unicode characters, starting at ``chr(192)`` and skipping surrogates.</span>

<span class="sd">    **Examples:**</span>

<span class="sd">    ```python</span>
<span class="sd">    get_symbol(2)</span>
<span class="sd">    #&gt; &#39;c&#39;</span>

<span class="sd">    get_symbol(200)</span>
<span class="sd">    #&gt; &#39;Ŕ&#39;</span>

<span class="sd">    get_symbol(20000)</span>
<span class="sd">    #&gt; &#39;京&#39;</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">52</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_einsum_symbols_base</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">55296</span><span class="p">:</span>
        <span class="c1"># Skip chr(57343) - chr(55296) as surrogates</span>
        <span class="k">return</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2048</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">140</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h3 id="opt_einsumshared_intermediates"><code>opt_einsum.shared_intermediates</code></h3>


<div class="doc doc-object doc-function">



<a id="opt_einsum.sharing.shared_intermediates"></a>
    <div class="doc doc-contents first">

      <p>Context in which contract intermediate results are shared.</p>
<p>Note that intermediate computations will not be garbage collected until
1. this context exits, and
2. the yielded cache is garbage collected (if it was captured).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><strong>cache</strong> - <em>(dict)</em> If specified, a user-stored dict in which intermediate results will be stored. This can be used to interleave sharing contexts.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><strong>cache</strong> - <em>(dict)</em> A dictionary in which sharing results are stored. If ignored,
    sharing results will be garbage collected when this context is
    exited. This dict can be passed to another context to resume
    sharing.</li>
</ul>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/sharing.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@contextlib</span><span class="o">.</span><span class="n">contextmanager</span>
<span class="k">def</span> <span class="nf">shared_intermediates</span><span class="p">(</span>
    <span class="n">cache</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CacheType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">CacheType</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context in which contract intermediate results are shared.</span>

<span class="sd">    Note that intermediate computations will not be garbage collected until</span>
<span class="sd">    1. this context exits, and</span>
<span class="sd">    2. the yielded cache is garbage collected (if it was captured).</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - **cache** - *(dict)* If specified, a user-stored dict in which intermediate results will be stored. This can be used to interleave sharing contexts.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - **cache** - *(dict)* A dictionary in which sharing results are stored. If ignored,</span>
<span class="sd">        sharing results will be garbage collected when this context is</span>
<span class="sd">        exited. This dict can be passed to another context to resume</span>
<span class="sd">        sharing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">_add_sharing_cache</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">cache</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">_remove_sharing_cache</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h3 id="opt_einsumpathsoptimal"><code>opt_einsum.paths.optimal</code></h3>


<div class="doc doc-object doc-function">



<a id="opt_einsum.paths.optimal"></a>
    <div class="doc doc-contents first">

      <p>Computes all possible pair contractions in a depth-first recursive manner,
sieving results based on <code>memory_limit</code> and the best path found so far.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>inputs</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="opt_einsum.typing.ArrayIndexType">ArrayIndexType</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of sets that represent the lhs side of the einsum subscript.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>output</code></td>
            <td>
                  <code><span title="opt_einsum.typing.ArrayIndexType">ArrayIndexType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Set that represents the rhs side of the overall einsum subscript.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>size_dict</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary of index sizes.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>memory_limit</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The maximum number of elements in a temporary array.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>path</code></td>            <td>
                  <code><span title="opt_einsum.typing.PathType">PathType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The optimal contraction order within the memory limit constraint.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
      <p>Examples:</p>
<div class="highlight"><pre><span></span><code><span class="n">isets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="s1">&#39;abd&#39;</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;ac&#39;</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;bdc&#39;</span><span class="p">)]</span>
<span class="n">oset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">idx_sizes</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
<span class="n">optimal</span><span class="p">(</span><span class="n">isets</span><span class="p">,</span> <span class="n">oset</span><span class="p">,</span> <span class="n">idx_sizes</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>
<span class="c1">#&gt; [(0, 2), (0, 1)]</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/paths.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">optimal</span><span class="p">(</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
    <span class="n">output</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
    <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">memory_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes all possible pair contractions in a depth-first recursive manner,</span>
<span class="sd">    sieving results based on `memory_limit` and the best path found so far.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        inputs: List of sets that represent the lhs side of the einsum subscript.</span>
<span class="sd">        output: Set that represents the rhs side of the overall einsum subscript.</span>
<span class="sd">        size_dict: Dictionary of index sizes.</span>
<span class="sd">        memory_limit: The maximum number of elements in a temporary array.</span>

<span class="sd">    Returns:</span>
<span class="sd">        path: The optimal contraction order within the memory limit constraint.</span>

<span class="sd">    Examples:</span>

<span class="sd">    ```python</span>
<span class="sd">    isets = [set(&#39;abd&#39;), set(&#39;ac&#39;), set(&#39;bdc&#39;)]</span>
<span class="sd">    oset = set(&#39;&#39;)</span>
<span class="sd">    idx_sizes = {&#39;a&#39;: 1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}</span>
<span class="sd">    optimal(isets, oset, idx_sizes, 5000)</span>
<span class="sd">    #&gt; [(0, 2), (0, 1)]</span>
<span class="sd">    ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">inputs_set</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>
    <span class="n">output_set</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

    <span class="n">best_flops</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;flops&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)}</span>
    <span class="n">best_ssa_path</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">:</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))),)}</span>
    <span class="n">size_cache</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">result_cache</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">,</span> <span class="n">ArrayIndexType</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_optimal_iterate</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">flops</span><span class="p">):</span>

        <span class="c1"># reached end of path (only ever get here if flops is best found so far)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">best_flops</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flops</span>
            <span class="n">best_ssa_path</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span>

        <span class="c1"># check all possible remaining paths</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">k12</span><span class="p">,</span> <span class="n">flops12</span> <span class="o">=</span> <span class="n">result_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">k12</span><span class="p">,</span> <span class="n">flops12</span> <span class="o">=</span> <span class="n">result_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_k12_flops</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output_set</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

            <span class="c1"># sieve based on current best flops</span>
            <span class="n">new_flops</span> <span class="o">=</span> <span class="n">flops</span> <span class="o">+</span> <span class="n">flops12</span>
            <span class="k">if</span> <span class="n">new_flops</span> <span class="o">&gt;=</span> <span class="n">best_flops</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="c1"># sieve based on memory limit</span>
            <span class="k">if</span> <span class="n">memory_limit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_UNLIMITED_MEM</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">size12</span> <span class="o">=</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">k12</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">size12</span> <span class="o">=</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">k12</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">k12</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

                <span class="c1"># possibly terminate this path with an all-terms einsum</span>
                <span class="k">if</span> <span class="n">size12</span> <span class="o">&gt;</span> <span class="n">memory_limit</span><span class="p">:</span>
                    <span class="n">new_flops</span> <span class="o">=</span> <span class="n">flops</span> <span class="o">+</span> <span class="n">_compute_oversize_flops</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">output_set</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_flops</span> <span class="o">&lt;</span> <span class="n">best_flops</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]:</span>
                        <span class="n">best_flops</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_flops</span>
                        <span class="n">best_ssa_path</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">remaining</span><span class="p">),)</span>
                    <span class="k">continue</span>

            <span class="c1"># add contraction and recurse into all remaining</span>
            <span class="n">_optimal_iterate</span><span class="p">(</span>
                <span class="n">path</span><span class="o">=</span><span class="n">path</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),),</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span> <span class="o">+</span> <span class="p">(</span><span class="n">k12</span><span class="p">,),</span>
                <span class="n">remaining</span><span class="o">=</span><span class="n">remaining</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)},</span>
                <span class="n">flops</span><span class="o">=</span><span class="n">new_flops</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="n">_optimal_iterate</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="p">(),</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputs_set</span><span class="p">,</span> <span class="n">remaining</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))),</span> <span class="n">flops</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ssa_to_linear</span><span class="p">(</span><span class="n">best_ssa_path</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h3 id="opt_einsumpathsgreedy"><code>opt_einsum.paths.greedy</code></h3>


<div class="doc doc-object doc-function">



<a id="opt_einsum.paths.greedy"></a>
    <div class="doc doc-contents first">

      <p>Finds the path by a three stage algorithm:</p>
<ol>
<li>Eagerly compute Hadamard products.</li>
<li>Greedily compute contractions to maximize <code>removed_size</code></li>
<li>Greedily compute outer products.</li>
</ol>
<p>This algorithm scales quadratically with respect to the
maximum number of elements sharing a common dim.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>inputs</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="opt_einsum.typing.ArrayIndexType">ArrayIndexType</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of sets that represent the lhs side of the einsum subscript</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>output</code></td>
            <td>
                  <code><span title="opt_einsum.typing.ArrayIndexType">ArrayIndexType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Set that represents the rhs side of the overall einsum subscript</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>size_dict</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary of index sizes</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>memory_limit</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The maximum number of elements in a temporary array</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>choose_fn</code></td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A function that chooses which contraction to perform from the queue</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>cost_fn</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A function that assigns a potential contraction a cost.</p>
              </div>
            </td>
            <td>
                  <code>&#39;memory-removed&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>path</code></td>            <td>
                  <code><span title="opt_einsum.typing.PathType">PathType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The contraction order (a list of tuples of ints).</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
      <p>Examples:</p>
<div class="codehilite"><pre><span></span><code>```python
isets = [set(&#39;abd&#39;), set(&#39;ac&#39;), set(&#39;bdc&#39;)]
oset = set(&#39;&#39;)
idx_sizes = {&#39;a&#39;: 1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}
greedy(isets, oset, idx_sizes)
<span class="gh">#</span>&gt; [(0, 2), (0, 1)]
```
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/paths.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span>
<span class="normal">726</span>
<span class="normal">727</span>
<span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">greedy</span><span class="p">(</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
    <span class="n">output</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
    <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">memory_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">choose_fn</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cost_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;memory-removed&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the path by a three stage algorithm:</span>

<span class="sd">    1. Eagerly compute Hadamard products.</span>
<span class="sd">    2. Greedily compute contractions to maximize `removed_size`</span>
<span class="sd">    3. Greedily compute outer products.</span>

<span class="sd">    This algorithm scales quadratically with respect to the</span>
<span class="sd">    maximum number of elements sharing a common dim.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        inputs: List of sets that represent the lhs side of the einsum subscript</span>
<span class="sd">        output: Set that represents the rhs side of the overall einsum subscript</span>
<span class="sd">        size_dict: Dictionary of index sizes</span>
<span class="sd">        memory_limit: The maximum number of elements in a temporary array</span>
<span class="sd">        choose_fn: A function that chooses which contraction to perform from the queue</span>
<span class="sd">        cost_fn: A function that assigns a potential contraction a cost.</span>

<span class="sd">    Returns:</span>
<span class="sd">        path: The contraction order (a list of tuples of ints).</span>

<span class="sd">    Examples:</span>

<span class="sd">        ```python</span>
<span class="sd">        isets = [set(&#39;abd&#39;), set(&#39;ac&#39;), set(&#39;bdc&#39;)]</span>
<span class="sd">        oset = set(&#39;&#39;)</span>
<span class="sd">        idx_sizes = {&#39;a&#39;: 1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}</span>
<span class="sd">        greedy(isets, oset, idx_sizes)</span>
<span class="sd">        #&gt; [(0, 2), (0, 1)]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">memory_limit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_UNLIMITED_MEM</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">branch</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="n">memory_limit</span><span class="p">,</span> <span class="n">nbranch</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cost_fn</span><span class="o">=</span><span class="n">cost_fn</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

    <span class="n">ssa_path</span> <span class="o">=</span> <span class="n">ssa_greedy_optimize</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="n">cost_fn</span><span class="o">=</span><span class="n">cost_fn</span><span class="p">,</span> <span class="n">choose_fn</span><span class="o">=</span><span class="n">choose_fn</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ssa_to_linear</span><span class="p">(</span><span class="n">ssa_path</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h3 id="opt_einsumpathsbranch"><code>opt_einsum.paths.branch</code></h3>


<div class="doc doc-object doc-function">



<a id="opt_einsum.paths.branch"></a>
    <div class="doc doc-contents first">

            <details class="quote">
              <summary>Source code in <code>opt_einsum/paths.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">490</span>
<span class="normal">491</span>
<span class="normal">492</span>
<span class="normal">493</span>
<span class="normal">494</span>
<span class="normal">495</span>
<span class="normal">496</span>
<span class="normal">497</span>
<span class="normal">498</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">branch</span><span class="p">(</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
    <span class="n">output</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
    <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">memory_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">**</span><span class="n">optimizer_kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">BranchBound</span><span class="p">(</span><span class="o">**</span><span class="n">optimizer_kwargs</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">optimizer</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="n">memory_limit</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div><h3 id="opt_einsumpathspathoptimizer"><code>opt_einsum.paths.PathOptimizer</code></h3>


<div class="doc doc-object doc-class">



<a id="opt_einsum.paths.PathOptimizer"></a>
    <div class="doc doc-contents first">


      <p>Base class for different path optimizers to inherit from.</p>
<p>Subclassed optimizers should define a call method with signature:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="n">memory_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        inputs : list[set[str]]</span>
<span class="sd">            The indices of each input array.</span>
<span class="sd">        outputs : set[str]</span>
<span class="sd">            The output indices</span>
<span class="sd">        size_dict : dict[str, int]</span>
<span class="sd">            The size of each index</span>
<span class="sd">        memory_limit : int, optional</span>
<span class="sd">            If given, the maximum allowed memory.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># ... compute path here ...</span>
    <span class="k">return</span> <span class="n">path</span>
</code></pre></div>
<p>where <code>path</code> is a list of int-tuples specifying a contraction order.</p>

              <details class="quote">
                <summary>Source code in <code>opt_einsum/paths.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">PathOptimizer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for different path optimizers to inherit from.</span>

<span class="sd">    Subclassed optimizers should define a call method with signature:</span>

<span class="sd">    ```python</span>
<span class="sd">    def __call__(self, inputs, output, size_dict, memory_limit=None):</span>
<span class="sd">        \&quot;\&quot;\&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            inputs : list[set[str]]</span>
<span class="sd">                The indices of each input array.</span>
<span class="sd">            outputs : set[str]</span>
<span class="sd">                The output indices</span>
<span class="sd">            size_dict : dict[str, int]</span>
<span class="sd">                The size of each index</span>
<span class="sd">            memory_limit : int, optional</span>
<span class="sd">                If given, the maximum allowed memory.</span>
<span class="sd">        \&quot;\&quot;\&quot;</span>
<span class="sd">        # ... compute path here ...</span>
<span class="sd">        return path</span>
<span class="sd">    ```</span>

<span class="sd">    where `path` is a list of int-tuples specifying a contraction order.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_check_args_against_first_call</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
        <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Utility that stateful optimizers can use to ensure they are not</span>
<span class="sd">        called with different contractions across separate runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_first_call_args&quot;</span><span class="p">):</span>
            <span class="c1"># simply set the attribute as currently there is no global PathOptimizer init</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_first_call_args</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">elif</span> <span class="n">args</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_call_args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The arguments specifying the contraction that this path optimizer &quot;</span>
                <span class="s2">&quot;instance was called with have changed - try creating a new instance.&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
        <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">memory_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">











  </div>

    </div>

</div><h3 id="opt_einsumpathsbranchbound"><code>opt_einsum.paths.BranchBound</code></h3>


<div class="doc doc-object doc-class">



<a id="opt_einsum.paths.BranchBound"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="opt_einsum.paths.PathOptimizer" href="#opt_einsum.paths.PathOptimizer">PathOptimizer</a></code></p>


              <details class="quote">
                <summary>Source code in <code>opt_einsum/paths.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">BranchBound</span><span class="p">(</span><span class="n">PathOptimizer</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">nbranch</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">cutoff_flops_factor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">minimize</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;flops&quot;</span><span class="p">,</span>
        <span class="n">cost_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;memory-removed&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Explores possible pair contractions in a depth-first recursive manner like</span>
<span class="sd">        the `optimal` approach, but with extra heuristic early pruning of branches</span>
<span class="sd">        as well sieving by `memory_limit` and the best path found so far.</span>


<span class="sd">        Parameters:</span>
<span class="sd">            nbranch: How many branches to explore at each contraction step. If None, explore</span>
<span class="sd">                all possible branches. If an integer, branch into this many paths at</span>
<span class="sd">                each step. Defaults to None.</span>
<span class="sd">            cutoff_flops_factor: If at any point, a path is doing this much worse than the best path</span>
<span class="sd">                found so far was, terminate it. The larger this is made, the more paths</span>
<span class="sd">                will be fully explored and the slower the algorithm. Defaults to 4.</span>
<span class="sd">            minimize: Whether to optimize the path with regard primarily to the total</span>
<span class="sd">                estimated flop-count, or the size of the largest intermediate. The</span>
<span class="sd">                option not chosen will still be used as a secondary criterion.</span>
<span class="sd">            cost_fn: A function that returns a heuristic &#39;cost&#39; of a potential contraction</span>
<span class="sd">                with which to sort candidates. Should have signature</span>
<span class="sd">                `cost_fn(size12, size1, size2, k12, k1, k2)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nbranch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nbranch</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The number of branches must be at least one, `nbranch=</span><span class="si">{</span><span class="n">nbranch</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span> <span class="o">=</span> <span class="n">nbranch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_flops_factor</span> <span class="o">=</span> <span class="n">cutoff_flops_factor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimize</span> <span class="o">=</span> <span class="n">minimize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_fn</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">_COST_FNS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cost_fn</span><span class="p">,</span> <span class="n">cost_fn</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">better</span> <span class="o">=</span> <span class="n">get_better_fn</span><span class="p">(</span><span class="n">minimize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;flops&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best_progress</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ssa_to_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
        <span class="n">output_</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
        <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">memory_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters:</span>
<span class="sd">            inputs_: List of sets that represent the lhs side of the einsum subscript</span>
<span class="sd">            output_: Set that represents the rhs side of the overall einsum subscript</span>
<span class="sd">            size_dict: Dictionary of index sizes</span>
<span class="sd">            memory_limit: The maximum number of elements in a temporary array</span>

<span class="sd">        Returns:</span>
<span class="sd">            path: The contraction order within the memory limit constraint.</span>

<span class="sd">        Examples:</span>

<span class="sd">        ```python</span>
<span class="sd">        isets = [set(&#39;abd&#39;), set(&#39;ac&#39;), set(&#39;bdc&#39;)]</span>
<span class="sd">        oset = set(&#39;&#39;)</span>
<span class="sd">        idx_sizes = {&#39;a&#39;: 1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}</span>
<span class="sd">        optimal(isets, oset, idx_sizes, 5000)</span>
<span class="sd">        #&gt; [(0, 2), (0, 1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_args_against_first_call</span><span class="p">(</span><span class="n">inputs_</span><span class="p">,</span> <span class="n">output_</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

        <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">,</span> <span class="n">inputs_</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">output_</span><span class="p">)</span>

        <span class="n">size_cache</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">}</span>
        <span class="n">result_cache</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">def</span> <span class="nf">_branch_iterate</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">flops</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>

            <span class="c1"># reached end of path (only ever get here if flops is best found so far)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flops</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
                <span class="k">return</span>

            <span class="k">def</span> <span class="nf">_assess_candidate</span><span class="p">(</span><span class="n">k1</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">k2</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
                <span class="c1"># find resulting indices and flops</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">k12</span><span class="p">,</span> <span class="n">flops12</span> <span class="o">=</span> <span class="n">result_cache</span><span class="p">[</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">k12</span><span class="p">,</span> <span class="n">flops12</span> <span class="o">=</span> <span class="n">result_cache</span><span class="p">[</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_k12_flops</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">size12</span> <span class="o">=</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">k12</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="n">size12</span> <span class="o">=</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">k12</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">k12</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

                <span class="n">new_flops</span> <span class="o">=</span> <span class="n">flops</span> <span class="o">+</span> <span class="n">flops12</span>
                <span class="n">new_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size12</span><span class="p">)</span>

                <span class="c1"># sieve based on current best i.e. check flops and size still better</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">better</span><span class="p">(</span><span class="n">new_flops</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]):</span>
                    <span class="k">return</span> <span class="kc">None</span>

                <span class="c1"># compare to how the best method was doing as this point</span>
                <span class="k">if</span> <span class="n">new_flops</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_progress</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">best_progress</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_flops</span>
                <span class="c1"># sieve based on current progress relative to best</span>
                <span class="k">elif</span> <span class="n">new_flops</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_flops_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_progress</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)]:</span>
                    <span class="k">return</span> <span class="kc">None</span>

                <span class="c1"># sieve based on memory limit</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">memory_limit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_UNLIMITED_MEM</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">size12</span> <span class="o">&gt;</span> <span class="n">memory_limit</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
                    <span class="c1"># terminate path here, but check all-terms contract first</span>
                    <span class="n">new_flops</span> <span class="o">=</span> <span class="n">flops</span> <span class="o">+</span> <span class="n">_compute_oversize_flops</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">output_</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_flops</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_flops</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">remaining</span><span class="p">),)</span>
                    <span class="k">return</span> <span class="kc">None</span>

                <span class="c1"># set cost heuristic in order to locally sort possible contractions</span>
                <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span> <span class="o">=</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
                <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_fn</span><span class="p">(</span><span class="n">size12</span><span class="p">,</span> <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span><span class="p">,</span> <span class="n">k12</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">cost</span><span class="p">,</span> <span class="n">flops12</span><span class="p">,</span> <span class="n">new_flops</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">k12</span>

            <span class="c1"># check all possible remaining paths</span>
            <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
                <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="c1"># initially ignore outer products</span>
                <span class="k">if</span> <span class="n">k1</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">k2</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="n">candidate</span> <span class="o">=</span> <span class="n">_assess_candidate</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">candidate</span><span class="p">:</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>

            <span class="c1"># assess outer products if nothing left</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
                    <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">candidate</span> <span class="o">=</span> <span class="n">_assess_candidate</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">candidate</span><span class="p">:</span>
                        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>

            <span class="c1"># recurse into all or some of the best candidate contractions</span>
            <span class="n">bi</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bi</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span><span class="p">)</span> <span class="ow">and</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_flops</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">k12</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
                <span class="n">_branch_iterate</span><span class="p">(</span>
                    <span class="n">path</span><span class="o">=</span><span class="n">path</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),),</span>
                    <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span> <span class="o">+</span> <span class="p">(</span><span class="n">k12</span><span class="p">,),</span>
                    <span class="n">remaining</span><span class="o">=</span><span class="p">(</span><span class="n">remaining</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">})</span> <span class="o">|</span> <span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)},</span>
                    <span class="n">flops</span><span class="o">=</span><span class="n">new_flops</span><span class="p">,</span>
                    <span class="n">size</span><span class="o">=</span><span class="n">new_size</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">bi</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">_branch_iterate</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="p">(),</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="n">remaining</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))),</span> <span class="n">flops</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="opt_einsum.paths.BranchBound.__call__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__call__</span><span class="p">(</span><span class="n">inputs_</span><span class="p">,</span> <span class="n">output_</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="n">memory_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>inputs_</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="opt_einsum.typing.ArrayIndexType">ArrayIndexType</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of sets that represent the lhs side of the einsum subscript</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>output_</code></td>
            <td>
                  <code><span title="opt_einsum.typing.ArrayIndexType">ArrayIndexType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Set that represents the rhs side of the overall einsum subscript</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>size_dict</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary of index sizes</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>memory_limit</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The maximum number of elements in a temporary array</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>path</code></td>            <td>
                  <code><span title="opt_einsum.typing.PathType">PathType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The contraction order within the memory limit constraint.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>
      <p>Examples:</p>
<p>```python
isets = [set('abd'), set('ac'), set('bdc')]
oset = set('')
idx_sizes = {'a': 1, 'b':2, 'c':3, 'd':4}
optimal(isets, oset, idx_sizes, 5000)</p>
<h3 id="opt_einsum.paths.BranchBound.__call__--0-2-0-1">&gt; [(0, 2), (0, 1)]</h3>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/paths.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span>
<span class="normal">398</span>
<span class="normal">399</span>
<span class="normal">400</span>
<span class="normal">401</span>
<span class="normal">402</span>
<span class="normal">403</span>
<span class="normal">404</span>
<span class="normal">405</span>
<span class="normal">406</span>
<span class="normal">407</span>
<span class="normal">408</span>
<span class="normal">409</span>
<span class="normal">410</span>
<span class="normal">411</span>
<span class="normal">412</span>
<span class="normal">413</span>
<span class="normal">414</span>
<span class="normal">415</span>
<span class="normal">416</span>
<span class="normal">417</span>
<span class="normal">418</span>
<span class="normal">419</span>
<span class="normal">420</span>
<span class="normal">421</span>
<span class="normal">422</span>
<span class="normal">423</span>
<span class="normal">424</span>
<span class="normal">425</span>
<span class="normal">426</span>
<span class="normal">427</span>
<span class="normal">428</span>
<span class="normal">429</span>
<span class="normal">430</span>
<span class="normal">431</span>
<span class="normal">432</span>
<span class="normal">433</span>
<span class="normal">434</span>
<span class="normal">435</span>
<span class="normal">436</span>
<span class="normal">437</span>
<span class="normal">438</span>
<span class="normal">439</span>
<span class="normal">440</span>
<span class="normal">441</span>
<span class="normal">442</span>
<span class="normal">443</span>
<span class="normal">444</span>
<span class="normal">445</span>
<span class="normal">446</span>
<span class="normal">447</span>
<span class="normal">448</span>
<span class="normal">449</span>
<span class="normal">450</span>
<span class="normal">451</span>
<span class="normal">452</span>
<span class="normal">453</span>
<span class="normal">454</span>
<span class="normal">455</span>
<span class="normal">456</span>
<span class="normal">457</span>
<span class="normal">458</span>
<span class="normal">459</span>
<span class="normal">460</span>
<span class="normal">461</span>
<span class="normal">462</span>
<span class="normal">463</span>
<span class="normal">464</span>
<span class="normal">465</span>
<span class="normal">466</span>
<span class="normal">467</span>
<span class="normal">468</span>
<span class="normal">469</span>
<span class="normal">470</span>
<span class="normal">471</span>
<span class="normal">472</span>
<span class="normal">473</span>
<span class="normal">474</span>
<span class="normal">475</span>
<span class="normal">476</span>
<span class="normal">477</span>
<span class="normal">478</span>
<span class="normal">479</span>
<span class="normal">480</span>
<span class="normal">481</span>
<span class="normal">482</span>
<span class="normal">483</span>
<span class="normal">484</span>
<span class="normal">485</span>
<span class="normal">486</span>
<span class="normal">487</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
    <span class="n">output_</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
    <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">memory_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters:</span>
<span class="sd">        inputs_: List of sets that represent the lhs side of the einsum subscript</span>
<span class="sd">        output_: Set that represents the rhs side of the overall einsum subscript</span>
<span class="sd">        size_dict: Dictionary of index sizes</span>
<span class="sd">        memory_limit: The maximum number of elements in a temporary array</span>

<span class="sd">    Returns:</span>
<span class="sd">        path: The contraction order within the memory limit constraint.</span>

<span class="sd">    Examples:</span>

<span class="sd">    ```python</span>
<span class="sd">    isets = [set(&#39;abd&#39;), set(&#39;ac&#39;), set(&#39;bdc&#39;)]</span>
<span class="sd">    oset = set(&#39;&#39;)</span>
<span class="sd">    idx_sizes = {&#39;a&#39;: 1, &#39;b&#39;:2, &#39;c&#39;:3, &#39;d&#39;:4}</span>
<span class="sd">    optimal(isets, oset, idx_sizes, 5000)</span>
<span class="sd">    #&gt; [(0, 2), (0, 1)]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_check_args_against_first_call</span><span class="p">(</span><span class="n">inputs_</span><span class="p">,</span> <span class="n">output_</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

    <span class="n">inputs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">frozenset</span><span class="p">,</span> <span class="n">inputs_</span><span class="p">))</span>  <span class="c1"># type: ignore</span>
    <span class="n">output</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">output_</span><span class="p">)</span>

    <span class="n">size_cache</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">}</span>
    <span class="n">result_cache</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_branch_iterate</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">flops</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>

        <span class="c1"># reached end of path (only ever get here if flops is best found so far)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flops</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
            <span class="k">return</span>

        <span class="k">def</span> <span class="nf">_assess_candidate</span><span class="p">(</span><span class="n">k1</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">k2</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">i</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
            <span class="c1"># find resulting indices and flops</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">k12</span><span class="p">,</span> <span class="n">flops12</span> <span class="o">=</span> <span class="n">result_cache</span><span class="p">[</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">k12</span><span class="p">,</span> <span class="n">flops12</span> <span class="o">=</span> <span class="n">result_cache</span><span class="p">[</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="n">calc_k12_flops</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">size12</span> <span class="o">=</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">k12</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">size12</span> <span class="o">=</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">k12</span><span class="p">]</span> <span class="o">=</span> <span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">k12</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

            <span class="n">new_flops</span> <span class="o">=</span> <span class="n">flops</span> <span class="o">+</span> <span class="n">flops12</span>
            <span class="n">new_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">size12</span><span class="p">)</span>

            <span class="c1"># sieve based on current best i.e. check flops and size still better</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">better</span><span class="p">(</span><span class="n">new_flops</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]):</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># compare to how the best method was doing as this point</span>
            <span class="k">if</span> <span class="n">new_flops</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_progress</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best_progress</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_flops</span>
            <span class="c1"># sieve based on current progress relative to best</span>
            <span class="k">elif</span> <span class="n">new_flops</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_flops_factor</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_progress</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)]:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># sieve based on memory limit</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">memory_limit</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_UNLIMITED_MEM</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">size12</span> <span class="o">&gt;</span> <span class="n">memory_limit</span><span class="p">):</span>  <span class="c1"># type: ignore</span>
                <span class="c1"># terminate path here, but check all-terms contract first</span>
                <span class="n">new_flops</span> <span class="o">=</span> <span class="n">flops</span> <span class="o">+</span> <span class="n">_compute_oversize_flops</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">output_</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_flops</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_flops</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">remaining</span><span class="p">),)</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># set cost heuristic in order to locally sort possible contractions</span>
            <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span> <span class="o">=</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">size_cache</span><span class="p">[</span><span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>
            <span class="n">cost</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_fn</span><span class="p">(</span><span class="n">size12</span><span class="p">,</span> <span class="n">size1</span><span class="p">,</span> <span class="n">size2</span><span class="p">,</span> <span class="n">k12</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">cost</span><span class="p">,</span> <span class="n">flops12</span><span class="p">,</span> <span class="n">new_flops</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">k12</span>

        <span class="c1"># check all possible remaining paths</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
            <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

            <span class="c1"># initially ignore outer products</span>
            <span class="k">if</span> <span class="n">k1</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">k2</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">candidate</span> <span class="o">=</span> <span class="n">_assess_candidate</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">candidate</span><span class="p">:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># assess outer products if nothing left</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">remaining</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span>
                <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">inputs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="n">_assess_candidate</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">candidate</span><span class="p">:</span>
                    <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">candidate</span><span class="p">)</span>

        <span class="c1"># recurse into all or some of the best candidate contractions</span>
        <span class="n">bi</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">bi</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span><span class="p">)</span> <span class="ow">and</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">new_flops</span><span class="p">,</span> <span class="n">new_size</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">k12</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
            <span class="n">_branch_iterate</span><span class="p">(</span>
                <span class="n">path</span><span class="o">=</span><span class="n">path</span> <span class="o">+</span> <span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),),</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span> <span class="o">+</span> <span class="p">(</span><span class="n">k12</span><span class="p">,),</span>
                <span class="n">remaining</span><span class="o">=</span><span class="p">(</span><span class="n">remaining</span> <span class="o">-</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">})</span> <span class="o">|</span> <span class="p">{</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)},</span>
                <span class="n">flops</span><span class="o">=</span><span class="n">new_flops</span><span class="p">,</span>
                <span class="n">size</span><span class="o">=</span><span class="n">new_size</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">bi</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">_branch_iterate</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="p">(),</span> <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span> <span class="n">remaining</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))),</span> <span class="n">flops</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h2 id="opt_einsum.paths.BranchBound.__init__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">nbranch</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cutoff_flops_factor</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">minimize</span><span class="o">=</span><span class="s1">&#39;flops&#39;</span><span class="p">,</span> <span class="n">cost_fn</span><span class="o">=</span><span class="s1">&#39;memory-removed&#39;</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">

      <p>Explores possible pair contractions in a depth-first recursive manner like
the <code>optimal</code> approach, but with extra heuristic early pruning of branches
as well sieving by <code>memory_limit</code> and the best path found so far.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>nbranch</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>How many branches to explore at each contraction step. If None, explore
all possible branches. If an integer, branch into this many paths at
each step. Defaults to None.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>cutoff_flops_factor</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If at any point, a path is doing this much worse than the best path
found so far was, terminate it. The larger this is made, the more paths
will be fully explored and the slower the algorithm. Defaults to 4.</p>
              </div>
            </td>
            <td>
                  <code>4</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>minimize</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to optimize the path with regard primarily to the total
estimated flop-count, or the size of the largest intermediate. The
option not chosen will still be used as a secondary criterion.</p>
              </div>
            </td>
            <td>
                  <code>&#39;flops&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>cost_fn</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A function that returns a heuristic 'cost' of a potential contraction
with which to sort candidates. Should have signature
<code>cost_fn(size12, size1, size2, k12, k1, k2)</code>.</p>
              </div>
            </td>
            <td>
                  <code>&#39;memory-removed&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/paths.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">nbranch</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cutoff_flops_factor</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">minimize</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;flops&quot;</span><span class="p">,</span>
    <span class="n">cost_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;memory-removed&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explores possible pair contractions in a depth-first recursive manner like</span>
<span class="sd">    the `optimal` approach, but with extra heuristic early pruning of branches</span>
<span class="sd">    as well sieving by `memory_limit` and the best path found so far.</span>


<span class="sd">    Parameters:</span>
<span class="sd">        nbranch: How many branches to explore at each contraction step. If None, explore</span>
<span class="sd">            all possible branches. If an integer, branch into this many paths at</span>
<span class="sd">            each step. Defaults to None.</span>
<span class="sd">        cutoff_flops_factor: If at any point, a path is doing this much worse than the best path</span>
<span class="sd">            found so far was, terminate it. The larger this is made, the more paths</span>
<span class="sd">            will be fully explored and the slower the algorithm. Defaults to 4.</span>
<span class="sd">        minimize: Whether to optimize the path with regard primarily to the total</span>
<span class="sd">            estimated flop-count, or the size of the largest intermediate. The</span>
<span class="sd">            option not chosen will still be used as a secondary criterion.</span>
<span class="sd">        cost_fn: A function that returns a heuristic &#39;cost&#39; of a potential contraction</span>
<span class="sd">            with which to sort candidates. Should have signature</span>
<span class="sd">            `cost_fn(size12, size1, size2, k12, k1, k2)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nbranch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="n">nbranch</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The number of branches must be at least one, `nbranch=</span><span class="si">{</span><span class="n">nbranch</span><span class="si">}</span><span class="s2">`.&quot;</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span> <span class="o">=</span> <span class="n">nbranch</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cutoff_flops_factor</span> <span class="o">=</span> <span class="n">cutoff_flops_factor</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">minimize</span> <span class="o">=</span> <span class="n">minimize</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cost_fn</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">_COST_FNS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cost_fn</span><span class="p">,</span> <span class="n">cost_fn</span><span class="p">)</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">better</span> <span class="o">=</span> <span class="n">get_better_fn</span><span class="p">(</span><span class="n">minimize</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;flops&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">best_progress</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h3 id="opt_einsumpath_randomrandomoptimizer"><code>opt_einsum.path_random.RandomOptimizer</code></h3>


<div class="doc doc-object doc-class">



<a id="opt_einsum.path_random.RandomOptimizer"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="opt_einsum.paths.PathOptimizer" href="#opt_einsum.paths.PathOptimizer">PathOptimizer</a></code></p>


      <p>Base class for running any random path finder that benefits
from repeated calling, possibly in a parallel fashion. Custom random
optimizers should subclass this, and the <code>setup</code> method should be
implemented with the following signature:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">):</span>
    <span class="c1"># custom preparation here ...</span>
    <span class="k">return</span> <span class="n">trial_fn</span><span class="p">,</span> <span class="n">trial_args</span>
</code></pre></div>
<p>Where <code>trial_fn</code> itself should have the signature::</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">trial_fn</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_args</span><span class="p">):</span>
    <span class="c1"># custom computation of path here</span>
    <span class="k">return</span> <span class="n">ssa_path</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">size</span>
</code></pre></div>
<p>Where <code>r</code> is the run number and could for example be used to seed a
random number generator. See <code>RandomGreedy</code> for an example.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>max_repeats</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The maximum number of repeat trials to have.</p>
              </div>
            </td>
            <td>
                  <code>32</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>max_time</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[float]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The maximum amount of time to run the algorithm for.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>minimize</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to favour paths that minimize the total estimated flop-count or
the size of the largest intermediate created.</p>
              </div>
            </td>
            <td>
                  <code>&#39;flops&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>parallel</code></td>
            <td>
                  <code><span title="typing.Union">Union</span>[bool, <span title="decimal.Decimal">Decimal</span>, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to parallelize the random trials, by default <code>False</code>. If
<code>True</code>, use a <code>concurrent.futures.ProcessPoolExecutor</code> with the same
number of processes as cores. If an integer is specified, use that many
processes instead. Finally, you can supply a custom executor-pool which
should have an API matching that of the python 3 standard library
module <code>concurrent.futures</code>. Namely, a <code>submit</code> method that returns
<code>Future</code> objects, themselves with <code>result</code> and <code>cancel</code> methods.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>pre_dispatch</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If running in parallel, how many jobs to pre-dispatch so as to avoid
submitting all jobs at once. Should also be more than twice the number
of workers to avoid under-subscription. Default: 128.</p>
              </div>
            </td>
            <td>
                  <code>128</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><a class="autorefs autorefs-internal" title="opt_einsum.path_random.RandomOptimizer.path" href="#opt_einsum.path_random.RandomOptimizer.path">path</a></code></td>
            <td>
                  <code><span title="opt_einsum.typing.PathType">PathType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The best path found so far.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="opt_einsum.path_random.RandomOptimizer.costs">costs</span></code></td>
            <td>
                  <code><span title="typing.List">List</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The list of each trial's costs found so far.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="opt_einsum.path_random.RandomOptimizer.sizes">sizes</span></code></td>
            <td>
                  <code><span title="typing.List">List</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The list of each trial's largest intermediate size so far.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>opt_einsum/path_random.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">RandomOptimizer</span><span class="p">(</span><span class="n">paths</span><span class="o">.</span><span class="n">PathOptimizer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for running any random path finder that benefits</span>
<span class="sd">    from repeated calling, possibly in a parallel fashion. Custom random</span>
<span class="sd">    optimizers should subclass this, and the `setup` method should be</span>
<span class="sd">    implemented with the following signature:</span>

<span class="sd">    ```python</span>
<span class="sd">    def setup(self, inputs, output, size_dict):</span>
<span class="sd">        # custom preparation here ...</span>
<span class="sd">        return trial_fn, trial_args</span>
<span class="sd">    ```</span>

<span class="sd">    Where `trial_fn` itself should have the signature::</span>

<span class="sd">    ```python</span>
<span class="sd">    def trial_fn(r, *trial_args):</span>
<span class="sd">        # custom computation of path here</span>
<span class="sd">        return ssa_path, cost, size</span>
<span class="sd">    ```</span>

<span class="sd">    Where `r` is the run number and could for example be used to seed a</span>
<span class="sd">    random number generator. See `RandomGreedy` for an example.</span>


<span class="sd">    Parameters:</span>
<span class="sd">        max_repeats: The maximum number of repeat trials to have.</span>
<span class="sd">        max_time: The maximum amount of time to run the algorithm for.</span>
<span class="sd">        minimize:  Whether to favour paths that minimize the total estimated flop-count or</span>
<span class="sd">            the size of the largest intermediate created.</span>
<span class="sd">        parallel: Whether to parallelize the random trials, by default `False`. If</span>
<span class="sd">            `True`, use a `concurrent.futures.ProcessPoolExecutor` with the same</span>
<span class="sd">            number of processes as cores. If an integer is specified, use that many</span>
<span class="sd">            processes instead. Finally, you can supply a custom executor-pool which</span>
<span class="sd">            should have an API matching that of the python 3 standard library</span>
<span class="sd">            module `concurrent.futures`. Namely, a `submit` method that returns</span>
<span class="sd">            `Future` objects, themselves with `result` and `cancel` methods.</span>
<span class="sd">        pre_dispatch: If running in parallel, how many jobs to pre-dispatch so as to avoid</span>
<span class="sd">            submitting all jobs at once. Should also be more than twice the number</span>
<span class="sd">            of workers to avoid under-subscription. Default: 128.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        path: The best path found so far.</span>
<span class="sd">        costs: The list of each trial&#39;s costs found so far.</span>
<span class="sd">        sizes: The list of each trial&#39;s largest intermediate size so far.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">max_repeats</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">32</span><span class="p">,</span>
        <span class="n">max_time</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">minimize</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;flops&quot;</span><span class="p">,</span>
        <span class="n">parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">pre_dispatch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span>
    <span class="p">):</span>

        <span class="k">if</span> <span class="n">minimize</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;flops&quot;</span><span class="p">,</span> <span class="s2">&quot;size&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`minimize` should be one of {&#39;flops&#39;, &#39;size&#39;}.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_repeats</span> <span class="o">=</span> <span class="n">max_repeats</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_time</span> <span class="o">=</span> <span class="n">max_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimize</span> <span class="o">=</span> <span class="n">minimize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">better</span> <span class="o">=</span> <span class="n">paths</span><span class="o">.</span><span class="n">get_better_fn</span><span class="p">(</span><span class="n">minimize</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parallel</span> <span class="o">=</span> <span class="n">parallel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_dispatch</span> <span class="o">=</span> <span class="n">pre_dispatch</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">costs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;flops&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="s2">&quot;size&quot;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_repeats_start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="p">:</span> <span class="n">Any</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="p">:</span> <span class="n">Any</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The best path found so far.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">paths</span><span class="o">.</span><span class="n">ssa_to_linear</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span>

    <span class="nd">@parallel</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parallel</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># shutdown any previous executor if we are managing it</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_managing_executor&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parallel</span> <span class="o">=</span> <span class="n">parallel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_managing_executor</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">parallel</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">parallel</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="n">ProcessPoolExecutor</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_managing_executor</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parallel</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">)):</span>
            <span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parallel</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_managing_executor</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span>

        <span class="c1"># assume a pool-executor has been supplied</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="o">=</span> <span class="n">parallel</span>

    <span class="k">def</span> <span class="nf">_gen_results_parallel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">trial_fn</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lazily generate results from an executor without submitting all jobs at once.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

        <span class="c1"># the idea here is to submit at least ``pre_dispatch`` jobs *before* we</span>
        <span class="c1"># yield any results, then do both in tandem, before draining the queue</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_dispatch</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">trial_fn</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="p">:</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span><span class="o">.</span><span class="n">result</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_cancel_futures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_futures</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">cancel</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
        <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
        <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">memory_limit</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_args_against_first_call</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

        <span class="c1"># start a timer?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

        <span class="n">trial_fn</span><span class="p">,</span> <span class="n">trial_args</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>

        <span class="n">r_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_repeats_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">costs</span><span class="p">)</span>
        <span class="n">r_stop</span> <span class="o">=</span> <span class="n">r_start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_repeats</span>
        <span class="n">repeats</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">r_start</span><span class="p">,</span> <span class="n">r_stop</span><span class="p">)</span>

        <span class="c1"># create the trials lazily</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trials</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gen_results_parallel</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="n">trial_fn</span><span class="p">,</span> <span class="n">trial_args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">trials</span> <span class="o">=</span> <span class="p">(</span><span class="n">trial_fn</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">trial_args</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">repeats</span><span class="p">)</span>

        <span class="c1"># assess the trials</span>
        <span class="k">for</span> <span class="n">ssa_path</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">trials</span><span class="p">:</span>

            <span class="c1"># keep track of all costs and sizes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

            <span class="c1"># check if we have found a new best</span>
            <span class="n">found_new_best</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">better</span><span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">found_new_best</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;flops&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">size</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">best</span><span class="p">[</span><span class="s2">&quot;ssa_path&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ssa_path</span>

            <span class="c1"># check if we have run out of time</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">t0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_time</span><span class="p">):</span>
                <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cancel_futures</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>

    <span class="k">def</span> <span class="fm">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if we created the parallel pool-executor, shut it down</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_managing_executor&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_executor</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h2 id="opt_einsum.path_random.RandomOptimizer.path" class="doc doc-heading">
            <code class=" language-python"><span class="n">path</span><span class="p">:</span> <span class="n">PathType</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

      <p>The best path found so far.</p>
    </div>

</div>





  </div>

    </div>

</div><h3 id="opt_einsumpath_randomrandomgreedy"><code>opt_einsum.path_random.RandomGreedy</code></h3>


<div class="doc doc-object doc-class">



<a id="opt_einsum.path_random.RandomGreedy"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="opt_einsum.path_random.RandomOptimizer" href="#opt_einsum.path_random.RandomOptimizer">RandomOptimizer</a></code></p>


              <details class="quote">
                <summary>Source code in <code>opt_einsum/path_random.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">RandomGreedy</span><span class="p">(</span><span class="n">RandomOptimizer</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">cost_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;memory-removed-jitter&quot;</span><span class="p">,</span>
        <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">rel_temperature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">nbranch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            cost_fn: A function that returns a heuristic &#39;cost&#39; of a potential contraction</span>
<span class="sd">                    with which to sort candidates. Should have signature</span>
<span class="sd">                    `cost_fn(size12, size1, size2, k12, k1, k2)`.</span>
<span class="sd">            temperature: When choosing a possible contraction, its relative probability will be</span>
<span class="sd">                    proportional to `exp(-cost / temperature)`. Thus the larger</span>
<span class="sd">                    `temperature` is, the further random paths will stray from the normal</span>
<span class="sd">                    &#39;greedy&#39; path. Conversely, if set to zero, only paths with exactly the</span>
<span class="sd">                    same cost as the best at each step will be explored.</span>
<span class="sd">            rel_temperature: Whether to normalize the ``temperature`` at each step to the scale of</span>
<span class="sd">                    the best cost. This is generally beneficial as the magnitude of costs</span>
<span class="sd">                    can vary significantly throughout a contraction. If False, the</span>
<span class="sd">                    algorithm will end up branching when the absolute cost is low, but</span>
<span class="sd">                    stick to the &#39;greedy&#39; path when the cost is high - this can also be</span>
<span class="sd">                    beneficial.</span>
<span class="sd">            nbranch: How many potential paths to calculate probability for and choose from at each step.</span>
<span class="sd">            kwargs: Supplied to RandomOptimizer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_fn</span> <span class="o">=</span> <span class="n">cost_fn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rel_temperature</span> <span class="o">=</span> <span class="n">rel_temperature</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span> <span class="o">=</span> <span class="n">nbranch</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">choose_fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The function that chooses which contraction to take - make this a</span>
<span class="sd">        property so that ``temperature`` and ``nbranch`` etc. can be updated</span>
<span class="sd">        between runs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span>
            <span class="n">thermal_chooser</span><span class="p">,</span>
            <span class="n">temperature</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">temperature</span><span class="p">,</span>
            <span class="n">nbranch</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span><span class="p">,</span>
            <span class="n">rel_temperature</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">rel_temperature</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
        <span class="n">output</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
        <span class="n">size_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="n">fn</span> <span class="o">=</span> <span class="n">_trial_greedy_ssa_path_and_cost</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">choose_fn</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_fn</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">,</span> <span class="n">args</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h2 id="opt_einsum.path_random.RandomGreedy.choose_fn" class="doc doc-heading">
            <code class=" language-python"><span class="n">choose_fn</span><span class="p">:</span> <span class="n">Any</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h2>


    <div class="doc doc-contents ">

      <p>The function that chooses which contraction to take - make this a
property so that <code>temperature</code> and <code>nbranch</code> etc. can be updated
between runs.</p>
    </div>

</div>



<div class="doc doc-object doc-function">


<h2 id="opt_einsum.path_random.RandomGreedy.__init__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">cost_fn</span><span class="o">=</span><span class="s1">&#39;memory-removed-jitter&#39;</span><span class="p">,</span> <span class="n">temperature</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">rel_temperature</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nbranch</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>cost_fn</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A function that returns a heuristic 'cost' of a potential contraction
    with which to sort candidates. Should have signature
    <code>cost_fn(size12, size1, size2, k12, k1, k2)</code>.</p>
              </div>
            </td>
            <td>
                  <code>&#39;memory-removed-jitter&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>temperature</code></td>
            <td>
                  <code>float</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>When choosing a possible contraction, its relative probability will be
    proportional to <code>exp(-cost / temperature)</code>. Thus the larger
    <code>temperature</code> is, the further random paths will stray from the normal
    'greedy' path. Conversely, if set to zero, only paths with exactly the
    same cost as the best at each step will be explored.</p>
              </div>
            </td>
            <td>
                  <code>1.0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>rel_temperature</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to normalize the <code>temperature</code> at each step to the scale of
    the best cost. This is generally beneficial as the magnitude of costs
    can vary significantly throughout a contraction. If False, the
    algorithm will end up branching when the absolute cost is low, but
    stick to the 'greedy' path when the cost is high - this can also be
    beneficial.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>nbranch</code></td>
            <td>
                  <code>int</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>How many potential paths to calculate probability for and choose from at each step.</p>
              </div>
            </td>
            <td>
                  <code>8</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>kwargs</code></td>
            <td>
                  <code><span title="typing.Any">Any</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Supplied to RandomOptimizer.</p>
              </div>
            </td>
            <td>
                  <code>{}</code>
            </td>
          </tr>
      </tbody>
    </table>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/path_random.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">cost_fn</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;memory-removed-jitter&quot;</span><span class="p">,</span>
    <span class="n">temperature</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">rel_temperature</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">nbranch</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        cost_fn: A function that returns a heuristic &#39;cost&#39; of a potential contraction</span>
<span class="sd">                with which to sort candidates. Should have signature</span>
<span class="sd">                `cost_fn(size12, size1, size2, k12, k1, k2)`.</span>
<span class="sd">        temperature: When choosing a possible contraction, its relative probability will be</span>
<span class="sd">                proportional to `exp(-cost / temperature)`. Thus the larger</span>
<span class="sd">                `temperature` is, the further random paths will stray from the normal</span>
<span class="sd">                &#39;greedy&#39; path. Conversely, if set to zero, only paths with exactly the</span>
<span class="sd">                same cost as the best at each step will be explored.</span>
<span class="sd">        rel_temperature: Whether to normalize the ``temperature`` at each step to the scale of</span>
<span class="sd">                the best cost. This is generally beneficial as the magnitude of costs</span>
<span class="sd">                can vary significantly throughout a contraction. If False, the</span>
<span class="sd">                algorithm will end up branching when the absolute cost is low, but</span>
<span class="sd">                stick to the &#39;greedy&#39; path when the cost is high - this can also be</span>
<span class="sd">                beneficial.</span>
<span class="sd">        nbranch: How many potential paths to calculate probability for and choose from at each step.</span>
<span class="sd">        kwargs: Supplied to RandomOptimizer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">cost_fn</span> <span class="o">=</span> <span class="n">cost_fn</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">temperature</span> <span class="o">=</span> <span class="n">temperature</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">rel_temperature</span> <span class="o">=</span> <span class="n">rel_temperature</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">nbranch</span> <span class="o">=</span> <span class="n">nbranch</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h3 id="opt_einsumpathsdynamicprogramming"><code>opt_einsum.paths.DynamicProgramming</code></h3>


<div class="doc doc-object doc-class">



<a id="opt_einsum.paths.DynamicProgramming"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="opt_einsum.paths.PathOptimizer" href="#opt_einsum.paths.PathOptimizer">PathOptimizer</a></code></p>


      <p>Finds the optimal path of pairwise contractions without intermediate outer
products based a dynamic programming approach presented in
Phys. Rev. E 90, 033315 (2014) (the corresponding preprint is publicly
available at https://arxiv.org/abs/1304.6112). This method is especially
well-suited in the area of tensor network states, where it usually
outperforms all the other optimization strategies.</p>
<p>This algorithm shows exponential scaling with the number of inputs
in the worst case scenario (see example below). If the graph to be
contracted consists of disconnected subgraphs, the algorithm scales
linearly in the number of disconnected subgraphs and only exponentially
with the number of inputs per subgraph.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>minimize</code></td>
            <td>
                  <code>str</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>What to minimize:
- 'flops' - minimize the number of flops
- 'size' - minimize the size of the largest intermediate
- 'write' - minimize the size of all intermediate tensors
- 'combo' - minimize <code>flops + alpha * write</code> summed over intermediates, a default ratio of alpha=64
is used, or it can be customized with <code>f'combo-{alpha}'</code>
- 'limit' - minimize <code>max(flops, alpha * write)</code> summed over intermediates, a default ratio of alpha=64
is used, or it can be customized with <code>f'limit-{alpha}'</code>
- callable - a custom local cost function</p>
              </div>
            </td>
            <td>
                  <code>&#39;flops&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>cost_cap</code></td>
            <td>
                  <code><span title="typing.Union">Union</span>[bool, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>How to implement cost-capping:
- True - iteratively increase the cost-cap
- False - implement no cost-cap at all
- int - use explicit cost cap</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>search_outer</code></td>
            <td>
                  <code>bool</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>In rare circumstances the optimal contraction may involve an outer
product, this option allows searching such contractions but may well
slow down the path finding considerably on all but very small graphs.</p>
              </div>
            </td>
            <td>
                  <code>False</code>
            </td>
          </tr>
      </tbody>
    </table>

              <details class="quote">
                <summary>Source code in <code>opt_einsum/paths.py</code></summary>
                <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span>
<span class="normal">1116</span>
<span class="normal">1117</span>
<span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span> <span class="nc">DynamicProgramming</span><span class="p">(</span><span class="n">PathOptimizer</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the optimal path of pairwise contractions without intermediate outer</span>
<span class="sd">    products based a dynamic programming approach presented in</span>
<span class="sd">    Phys. Rev. E 90, 033315 (2014) (the corresponding preprint is publicly</span>
<span class="sd">    available at https://arxiv.org/abs/1304.6112). This method is especially</span>
<span class="sd">    well-suited in the area of tensor network states, where it usually</span>
<span class="sd">    outperforms all the other optimization strategies.</span>

<span class="sd">    This algorithm shows exponential scaling with the number of inputs</span>
<span class="sd">    in the worst case scenario (see example below). If the graph to be</span>
<span class="sd">    contracted consists of disconnected subgraphs, the algorithm scales</span>
<span class="sd">    linearly in the number of disconnected subgraphs and only exponentially</span>
<span class="sd">    with the number of inputs per subgraph.</span>

<span class="sd">    Parameters:</span>
<span class="sd">        minimize: What to minimize:</span>
<span class="sd">            - &#39;flops&#39; - minimize the number of flops</span>
<span class="sd">            - &#39;size&#39; - minimize the size of the largest intermediate</span>
<span class="sd">            - &#39;write&#39; - minimize the size of all intermediate tensors</span>
<span class="sd">            - &#39;combo&#39; - minimize `flops + alpha * write` summed over intermediates, a default ratio of alpha=64</span>
<span class="sd">            is used, or it can be customized with `f&#39;combo-{alpha}&#39;`</span>
<span class="sd">            - &#39;limit&#39; - minimize `max(flops, alpha * write)` summed over intermediates, a default ratio of alpha=64</span>
<span class="sd">            is used, or it can be customized with `f&#39;limit-{alpha}&#39;`</span>
<span class="sd">            - callable - a custom local cost function</span>

<span class="sd">        cost_cap: How to implement cost-capping:</span>
<span class="sd">            - True - iteratively increase the cost-cap</span>
<span class="sd">            - False - implement no cost-cap at all</span>
<span class="sd">            - int - use explicit cost cap</span>

<span class="sd">        search_outer: In rare circumstances the optimal contraction may involve an outer</span>
<span class="sd">            product, this option allows searching such contractions but may well</span>
<span class="sd">            slow down the path finding considerably on all but very small graphs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">minimize</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;flops&quot;</span><span class="p">,</span> <span class="n">cost_cap</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">search_outer</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimize</span> <span class="o">=</span> <span class="n">minimize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">search_outer</span> <span class="o">=</span> <span class="n">search_outer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cost_cap</span> <span class="o">=</span> <span class="n">cost_cap</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
        <span class="n">output_</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
        <span class="n">size_dict_</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
        <span class="n">memory_limit_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters:</span>
<span class="sd">            inputs_: List of sets that represent the lhs side of the einsum subscript</span>
<span class="sd">            output_: Set that represents the rhs side of the overall einsum subscript</span>
<span class="sd">            size_dict_: Dictionary of index sizes</span>
<span class="sd">            memory_limit_: The maximum number of elements in a temporary array</span>

<span class="sd">        Returns:</span>
<span class="sd">            path: The contraction order (a list of tuples of ints).</span>

<span class="sd">        Examples:</span>
<span class="sd">            ```python</span>
<span class="sd">            n_in = 3  # exponential scaling</span>
<span class="sd">            n_out = 2 # linear scaling</span>
<span class="sd">            s = dict()</span>
<span class="sd">            i_all = []</span>
<span class="sd">            for _ in range(n_out):</span>
<span class="sd">                i = [set() for _ in range(n_in)]</span>
<span class="sd">                for j in range(n_in):</span>
<span class="sd">                    for k in range(j+1, n_in):</span>
<span class="sd">                        c = oe.get_symbol(len(s))</span>
<span class="sd">                        i[j].add(c)</span>
<span class="sd">                        i[k].add(c)</span>
<span class="sd">                        s[c] = 2</span>
<span class="sd">                i_all.extend(i)</span>
<span class="sd">            o = DynamicProgramming()</span>
<span class="sd">            o(i_all, set(), s)</span>
<span class="sd">            #&gt; [(1, 2), (0, 4), (1, 2), (0, 2), (0, 1)]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_check_contraction</span><span class="p">,</span> <span class="n">naive_scale</span> <span class="o">=</span> <span class="n">_parse_minimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimize</span><span class="p">)</span>
        <span class="n">_check_outer</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_outer</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>

        <span class="n">ind_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">inputs_</span><span class="p">,</span> <span class="n">output_</span><span class="p">))</span>
        <span class="n">all_inds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_counts</span><span class="p">)</span>

        <span class="c1"># convert all indices to integers (makes set operations ~10 % faster)</span>
        <span class="n">symbol2int</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_inds</span><span class="p">)}</span>
        <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">symbol2int</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs_</span><span class="p">]</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">symbol2int</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">output_</span><span class="p">)</span>
        <span class="n">size_dict_canonical</span> <span class="o">=</span> <span class="p">{</span><span class="n">symbol2int</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">size_dict_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">symbol2int</span><span class="p">}</span>
        <span class="n">size_dict</span> <span class="o">=</span> <span class="p">[</span><span class="n">size_dict_canonical</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">size_dict_canonical</span><span class="p">))]</span>
        <span class="n">naive_cost</span> <span class="o">=</span> <span class="n">naive_scale</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">*</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">inputs</span><span class="p">,</span> <span class="n">inputs_done</span><span class="p">,</span> <span class="n">inputs_contractions</span> <span class="o">=</span> <span class="n">_dp_parse_out_single_term_ops</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">all_inds</span><span class="p">,</span> <span class="n">ind_counts</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="c1"># nothing left to do after single axis reductions!</span>
            <span class="k">return</span> <span class="n">_tree_to_sequence</span><span class="p">(</span><span class="n">simple_tree_tuple</span><span class="p">(</span><span class="n">inputs_done</span><span class="p">))</span>

        <span class="c1"># a list of all necessary contraction expressions for each of the</span>
        <span class="c1"># disconnected subgraphs and their size</span>
        <span class="n">subgraph_contractions</span> <span class="o">=</span> <span class="n">inputs_done</span>
        <span class="n">subgraph_contractions_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs_done</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_outer</span><span class="p">:</span>
            <span class="c1"># optimize everything together if we are considering outer products</span>
            <span class="n">subgraphs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subgraphs</span> <span class="o">=</span> <span class="n">_find_disconnected_subgraphs</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

        <span class="c1"># the bitmap set of all tensors is computed as it is needed to</span>
        <span class="c1"># compute set differences: s1 - s2 transforms into</span>
        <span class="c1"># s1 &amp; (all_tensors ^ s2)</span>
        <span class="n">all_tensors</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">:</span>

            <span class="c1"># dynamic programming approach to compute x[n] for subgraph g;</span>
            <span class="c1"># x[n][set of n tensors] = (indices, cost, contraction)</span>
            <span class="c1"># the set of n tensors is represented by a bitmap: if bit j is 1,</span>
            <span class="c1"># tensor j is in the set, e.g. 0b100101 = {0,2,5}; set unions</span>
            <span class="c1"># (intersections) can then be computed by bitwise or (and);</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="nb">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inputs_contractions</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="p">)</span>

            <span class="c1"># convert set of tensors g to a bitmap set:</span>
            <span class="n">bitmap_g</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="p">))</span>

            <span class="c1"># try to find contraction with cost &lt;= cost_cap and increase</span>
            <span class="c1"># cost_cap successively if no such contraction is found;</span>
            <span class="c1"># this is a major performance improvement; start with product of</span>
            <span class="c1"># output index dimensions as initial cost_cap</span>
            <span class="n">subgraph_inds</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">_bitmap_select</span><span class="p">(</span><span class="n">bitmap_g</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_cap</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">cost_cap</span> <span class="o">=</span> <span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">subgraph_inds</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_cap</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">cost_cap</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cost_cap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_cap</span>
            <span class="c1"># set the factor to increase the cost by each iteration (ensure &gt; 1)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subgraph_inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cost_increment</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cost_increment</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">size_dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">subgraph_inds</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>

            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">xn</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

                    <span class="c1"># try to combine solutions from x[m] and x[n-m]</span>
                    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">cost1</span><span class="p">,</span> <span class="n">contract1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                            <span class="k">for</span> <span class="n">s2</span><span class="p">,</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">cost2</span><span class="p">,</span> <span class="n">contract2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                                <span class="c1"># can only merge if s1 and s2 are disjoint</span>
                                <span class="c1"># and avoid e.g. s1={0}, s2={1} and s1={1}, s2={0}</span>
                                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">s1</span> <span class="o">&amp;</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">):</span>
                                    <span class="n">i1_cut_i2_wo_output</span> <span class="o">=</span> <span class="p">(</span><span class="n">i1</span> <span class="o">&amp;</span> <span class="n">i2</span><span class="p">)</span> <span class="o">-</span> <span class="n">output</span>

                                    <span class="c1"># maybe ignore outer products:</span>
                                    <span class="k">if</span> <span class="n">_check_outer</span><span class="p">(</span><span class="n">i1_cut_i2_wo_output</span><span class="p">):</span>

                                        <span class="n">i1_union_i2</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">|</span> <span class="n">i2</span>
                                        <span class="n">_check_contraction</span><span class="p">(</span>
                                            <span class="n">cost1</span><span class="p">,</span>
                                            <span class="n">cost2</span><span class="p">,</span>
                                            <span class="n">i1_union_i2</span><span class="p">,</span>
                                            <span class="n">size_dict</span><span class="p">,</span>
                                            <span class="n">cost_cap</span><span class="p">,</span>
                                            <span class="n">s1</span><span class="p">,</span>
                                            <span class="n">s2</span><span class="p">,</span>
                                            <span class="n">xn</span><span class="p">,</span>
                                            <span class="n">bitmap_g</span><span class="p">,</span>
                                            <span class="n">all_tensors</span><span class="p">,</span>
                                            <span class="n">inputs</span><span class="p">,</span>
                                            <span class="n">i1_cut_i2_wo_output</span><span class="p">,</span>
                                            <span class="n">memory_limit_</span><span class="p">,</span>
                                            <span class="n">contract1</span><span class="p">,</span>
                                            <span class="n">contract2</span><span class="p">,</span>
                                        <span class="p">)</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">cost_cap</span> <span class="o">&gt;</span> <span class="n">naive_cost</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No contraction found for given `memory_limit`.&quot;</span><span class="p">)</span>

                <span class="c1"># increase cost cap for next iteration:</span>
                <span class="n">cost_cap</span> <span class="o">=</span> <span class="n">cost_increment</span> <span class="o">*</span> <span class="n">cost_cap</span>

            <span class="n">i</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">contraction</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">subgraph_contractions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contraction</span><span class="p">)</span>
            <span class="n">subgraph_contractions_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">))</span>

        <span class="c1"># sort the subgraph contractions by the size of the subgraphs in</span>
        <span class="c1"># ascending order (will give the cheapest contractions); note that</span>
        <span class="c1"># outer products should be performed pairwise (to use BLAS functions)</span>
        <span class="n">subgraph_contractions</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">subgraph_contractions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subgraph_contractions_size</span><span class="p">)),</span>
                <span class="n">key</span><span class="o">=</span><span class="n">subgraph_contractions_size</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># build the final contraction tree</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">simple_tree_tuple</span><span class="p">(</span><span class="n">subgraph_contractions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_tree_to_sequence</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">









<div class="doc doc-object doc-function">


<h2 id="opt_einsum.paths.DynamicProgramming.__call__" class="doc doc-heading">
            <code class=" language-python"><span class="fm">__call__</span><span class="p">(</span><span class="n">inputs_</span><span class="p">,</span> <span class="n">output_</span><span class="p">,</span> <span class="n">size_dict_</span><span class="p">,</span> <span class="n">memory_limit_</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code>inputs_</code></td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="opt_einsum.typing.ArrayIndexType">ArrayIndexType</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of sets that represent the lhs side of the einsum subscript</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>output_</code></td>
            <td>
                  <code><span title="opt_einsum.typing.ArrayIndexType">ArrayIndexType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Set that represents the rhs side of the overall einsum subscript</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>size_dict_</code></td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[str, int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary of index sizes</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code>memory_limit_</code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[int]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The maximum number of elements in a temporary array</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>path</code></td>            <td>
                  <code><span title="opt_einsum.typing.PathType">PathType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The contraction order (a list of tuples of ints).</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Examples:</span></p>
    <div class="highlight"><pre><span></span><code><span class="n">n_in</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># exponential scaling</span>
<span class="n">n_out</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># linear scaling</span>
<span class="n">s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">i_all</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_out</span><span class="p">):</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_in</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_in</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_in</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">oe</span><span class="o">.</span><span class="n">get_symbol</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
            <span class="n">i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">i</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="n">s</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">i_all</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
<span class="n">o</span> <span class="o">=</span> <span class="n">DynamicProgramming</span><span class="p">()</span>
<span class="n">o</span><span class="p">(</span><span class="n">i_all</span><span class="p">,</span> <span class="nb">set</span><span class="p">(),</span> <span class="n">s</span><span class="p">)</span>
<span class="c1">#&gt; [(1, 2), (0, 4), (1, 2), (0, 2), (0, 1)]</span>
</code></pre></div>

            <details class="quote">
              <summary>Source code in <code>opt_einsum/paths.py</code></summary>
              <div class="codehilite"><table class="codehilitetable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span>
<span class="normal">1213</span>
<span class="normal">1214</span>
<span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span>
<span class="normal">1257</span>
<span class="normal">1258</span>
<span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span>
<span class="normal">1270</span>
<span class="normal">1271</span>
<span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span>
<span class="normal">1283</span>
<span class="normal">1284</span>
<span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">inputs_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ArrayIndexType</span><span class="p">],</span>
    <span class="n">output_</span><span class="p">:</span> <span class="n">ArrayIndexType</span><span class="p">,</span>
    <span class="n">size_dict_</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span>
    <span class="n">memory_limit_</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PathType</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters:</span>
<span class="sd">        inputs_: List of sets that represent the lhs side of the einsum subscript</span>
<span class="sd">        output_: Set that represents the rhs side of the overall einsum subscript</span>
<span class="sd">        size_dict_: Dictionary of index sizes</span>
<span class="sd">        memory_limit_: The maximum number of elements in a temporary array</span>

<span class="sd">    Returns:</span>
<span class="sd">        path: The contraction order (a list of tuples of ints).</span>

<span class="sd">    Examples:</span>
<span class="sd">        ```python</span>
<span class="sd">        n_in = 3  # exponential scaling</span>
<span class="sd">        n_out = 2 # linear scaling</span>
<span class="sd">        s = dict()</span>
<span class="sd">        i_all = []</span>
<span class="sd">        for _ in range(n_out):</span>
<span class="sd">            i = [set() for _ in range(n_in)]</span>
<span class="sd">            for j in range(n_in):</span>
<span class="sd">                for k in range(j+1, n_in):</span>
<span class="sd">                    c = oe.get_symbol(len(s))</span>
<span class="sd">                    i[j].add(c)</span>
<span class="sd">                    i[k].add(c)</span>
<span class="sd">                    s[c] = 2</span>
<span class="sd">            i_all.extend(i)</span>
<span class="sd">        o = DynamicProgramming()</span>
<span class="sd">        o(i_all, set(), s)</span>
<span class="sd">        #&gt; [(1, 2), (0, 4), (1, 2), (0, 2), (0, 1)]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_check_contraction</span><span class="p">,</span> <span class="n">naive_scale</span> <span class="o">=</span> <span class="n">_parse_minimize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minimize</span><span class="p">)</span>
    <span class="n">_check_outer</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">True</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_outer</span> <span class="k">else</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span>

    <span class="n">ind_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="n">inputs_</span><span class="p">,</span> <span class="n">output_</span><span class="p">))</span>
    <span class="n">all_inds</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ind_counts</span><span class="p">)</span>

    <span class="c1"># convert all indices to integers (makes set operations ~10 % faster)</span>
    <span class="n">symbol2int</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_inds</span><span class="p">)}</span>
    <span class="n">inputs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">symbol2int</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">inputs_</span><span class="p">]</span>
    <span class="n">output</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">symbol2int</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">output_</span><span class="p">)</span>
    <span class="n">size_dict_canonical</span> <span class="o">=</span> <span class="p">{</span><span class="n">symbol2int</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">size_dict_</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">symbol2int</span><span class="p">}</span>
    <span class="n">size_dict</span> <span class="o">=</span> <span class="p">[</span><span class="n">size_dict_canonical</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">size_dict_canonical</span><span class="p">))]</span>
    <span class="n">naive_cost</span> <span class="o">=</span> <span class="n">naive_scale</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)</span> <span class="o">*</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">inputs</span><span class="p">,</span> <span class="n">inputs_done</span><span class="p">,</span> <span class="n">inputs_contractions</span> <span class="o">=</span> <span class="n">_dp_parse_out_single_term_ops</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">all_inds</span><span class="p">,</span> <span class="n">ind_counts</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">inputs</span><span class="p">:</span>
        <span class="c1"># nothing left to do after single axis reductions!</span>
        <span class="k">return</span> <span class="n">_tree_to_sequence</span><span class="p">(</span><span class="n">simple_tree_tuple</span><span class="p">(</span><span class="n">inputs_done</span><span class="p">))</span>

    <span class="c1"># a list of all necessary contraction expressions for each of the</span>
    <span class="c1"># disconnected subgraphs and their size</span>
    <span class="n">subgraph_contractions</span> <span class="o">=</span> <span class="n">inputs_done</span>
    <span class="n">subgraph_contractions_size</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs_done</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">search_outer</span><span class="p">:</span>
        <span class="c1"># optimize everything together if we are considering outer products</span>
        <span class="n">subgraphs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">)))]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subgraphs</span> <span class="o">=</span> <span class="n">_find_disconnected_subgraphs</span><span class="p">(</span><span class="n">inputs</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>

    <span class="c1"># the bitmap set of all tensors is computed as it is needed to</span>
    <span class="c1"># compute set differences: s1 - s2 transforms into</span>
    <span class="c1"># s1 &amp; (all_tensors ^ s2)</span>
    <span class="n">all_tensors</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputs</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">subgraphs</span><span class="p">:</span>

        <span class="c1"># dynamic programming approach to compute x[n] for subgraph g;</span>
        <span class="c1"># x[n][set of n tensors] = (indices, cost, contraction)</span>
        <span class="c1"># the set of n tensors is represented by a bitmap: if bit j is 1,</span>
        <span class="c1"># tensor j is in the set, e.g. 0b100101 = {0,2,5}; set unions</span>
        <span class="c1"># (intersections) can then be computed by bitwise or (and);</span>
        <span class="n">x</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span><span class="nb">dict</span><span class="p">()</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">((</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">inputs</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inputs_contractions</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="p">)</span>

        <span class="c1"># convert set of tensors g to a bitmap set:</span>
        <span class="n">bitmap_g</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">g</span><span class="p">))</span>

        <span class="c1"># try to find contraction with cost &lt;= cost_cap and increase</span>
        <span class="c1"># cost_cap successively if no such contraction is found;</span>
        <span class="c1"># this is a major performance improvement; start with product of</span>
        <span class="c1"># output index dimensions as initial cost_cap</span>
        <span class="n">subgraph_inds</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">_bitmap_select</span><span class="p">(</span><span class="n">bitmap_g</span><span class="p">,</span> <span class="n">inputs</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_cap</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">cost_cap</span> <span class="o">=</span> <span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">subgraph_inds</span> <span class="o">&amp;</span> <span class="n">output</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_cap</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">cost_cap</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cost_cap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cost_cap</span>
        <span class="c1"># set the factor to increase the cost by each iteration (ensure &gt; 1)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">subgraph_inds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cost_increment</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cost_increment</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">size_dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span> <span class="n">subgraph_inds</span><span class="p">)),</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">xn</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

                <span class="c1"># try to combine solutions from x[m] and x[n-m]</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">s1</span><span class="p">,</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">cost1</span><span class="p">,</span> <span class="n">contract1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="k">for</span> <span class="n">s2</span><span class="p">,</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">cost2</span><span class="p">,</span> <span class="n">contract2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>

                            <span class="c1"># can only merge if s1 and s2 are disjoint</span>
                            <span class="c1"># and avoid e.g. s1={0}, s2={1} and s1={1}, s2={0}</span>
                            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">s1</span> <span class="o">&amp;</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">m</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="n">s2</span><span class="p">):</span>
                                <span class="n">i1_cut_i2_wo_output</span> <span class="o">=</span> <span class="p">(</span><span class="n">i1</span> <span class="o">&amp;</span> <span class="n">i2</span><span class="p">)</span> <span class="o">-</span> <span class="n">output</span>

                                <span class="c1"># maybe ignore outer products:</span>
                                <span class="k">if</span> <span class="n">_check_outer</span><span class="p">(</span><span class="n">i1_cut_i2_wo_output</span><span class="p">):</span>

                                    <span class="n">i1_union_i2</span> <span class="o">=</span> <span class="n">i1</span> <span class="o">|</span> <span class="n">i2</span>
                                    <span class="n">_check_contraction</span><span class="p">(</span>
                                        <span class="n">cost1</span><span class="p">,</span>
                                        <span class="n">cost2</span><span class="p">,</span>
                                        <span class="n">i1_union_i2</span><span class="p">,</span>
                                        <span class="n">size_dict</span><span class="p">,</span>
                                        <span class="n">cost_cap</span><span class="p">,</span>
                                        <span class="n">s1</span><span class="p">,</span>
                                        <span class="n">s2</span><span class="p">,</span>
                                        <span class="n">xn</span><span class="p">,</span>
                                        <span class="n">bitmap_g</span><span class="p">,</span>
                                        <span class="n">all_tensors</span><span class="p">,</span>
                                        <span class="n">inputs</span><span class="p">,</span>
                                        <span class="n">i1_cut_i2_wo_output</span><span class="p">,</span>
                                        <span class="n">memory_limit_</span><span class="p">,</span>
                                        <span class="n">contract1</span><span class="p">,</span>
                                        <span class="n">contract2</span><span class="p">,</span>
                                    <span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">cost_cap</span> <span class="o">&gt;</span> <span class="n">naive_cost</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;No contraction found for given `memory_limit`.&quot;</span><span class="p">)</span>

            <span class="c1"># increase cost cap for next iteration:</span>
            <span class="n">cost_cap</span> <span class="o">=</span> <span class="n">cost_increment</span> <span class="o">*</span> <span class="n">cost_cap</span>

        <span class="n">i</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">contraction</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">subgraph_contractions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">contraction</span><span class="p">)</span>
        <span class="n">subgraph_contractions_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">compute_size_by_dict</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">size_dict</span><span class="p">))</span>

    <span class="c1"># sort the subgraph contractions by the size of the subgraphs in</span>
    <span class="c1"># ascending order (will give the cheapest contractions); note that</span>
    <span class="c1"># outer products should be performed pairwise (to use BLAS functions)</span>
    <span class="n">subgraph_contractions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">subgraph_contractions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subgraph_contractions_size</span><span class="p">)),</span>
            <span class="n">key</span><span class="o">=</span><span class="n">subgraph_contractions_size</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># build the final contraction tree</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">simple_tree_tuple</span><span class="p">(</span><span class="n">subgraph_contractions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_tree_to_sequence</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>







  
  






                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": "..", "features": ["navigation.instant"], "search": "../assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="../assets/javascripts/bundle.081f42fc.min.js"></script>
      
        <script src="../javascript/config.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>